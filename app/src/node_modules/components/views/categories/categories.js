// react
var React           = require('react')
var Fluxxor         = require('fluxxor')
var StoreWatchMixin = Fluxxor.StoreWatchMixin

//components
var EntityTableWrap = require('components/table/EntityTableWrap')
var Load       = require('components/load')
var NavCategories = require('components/nav/nav-categories')

//util
var referencing = require('utils/referencing')

// bootstrap
var Grid  = require('react-bootstrap/lib/Grid')
var Row 	= require('react-bootstrap/lib/Row')
var Col 	= require('react-bootstrap/lib/Col')

//helpers
var _   = require('lodash')
var log = require('debug')('src:components:explore-by')

// display actions and recommendations by "category"
module.exports = React.createClass({
  mixins: [
    Fluxxor.FluxMixin(React),
    StoreWatchMixin('issues', 'groups', 'agencies','treatybodies','recommendations','actions')
  ],
  getInitialState: function(){
    return {
      defaultTaxonomy : 'issues'
    }
  },
  getStateFromFlux: function () {
    var flux = this.getFlux()

    // store loading conditions
    return {
      loading:
           flux.store('issues').isLoading()
        || flux.store("actions").isLoading()
        || flux.store("recommendations").isLoading()
        || flux.store('groups').isLoading()
        || flux.store('agencies').isLoading()
        || flux.store('treatybodies').isLoading()
    }
  },


  render: function () {
    var category = this.props.params.id
    return (
      <div className="hrc-categories-view">
        <NavCategories
          active = {this.props.params.id}
        />
        {this.renderContent()}
      </div>
    )
  },
  renderContent : function() {
    var category = this.props.params.id
    // show actions and recommendations by issues
    if (category === 'issues' && !this.state.issuesLoading) {
      // render both actions AND recommendation columns
      return this.renderMain(['actions','recommendations'],'countActions')
    } else if (category === 'groups' && !this.state.groupsLoading) {
      // render both actions AND recommendation columns
      return this.renderMain(['actions','recommendations'],'countActions')
    } else if (category === 'agencies' && !this.state.agenciesLoading) {
      // render both actions AND recommendation columns
      return this.renderMain(['actions'],'countActions')
    } else if (category === 'treatybodies' && !this.state.treatybodiesLoading) {
      return this.renderMain(['recommendations'],'countRecs')
    } else {
      return (<Load/>)
    }
  },
  // sortBy : 'countActions'
  renderMain : function (types,sortBy){
    var flux = this.getFlux()
    var category = this.props.params.id
    var title = flux.store(category).getTitle()

    // get all category items and prep with entity-counts
    // sort by number of actions/recs (reverse order)
    var entities = _.sortBy(this.getEntities(category,types),sortBy).reverse()
    // maximum value of any related entity (actions or recommendation)
    var maxValue = this.getMaxCount(entities,types)
    var maxValueActions = this.getMaxCount(entities,['actions'])
    var maxValueRecs = this.getMaxCount(entities,['recommendations'])
    // the table columns
    var cols = this.getColumns(title,types,maxValue)
    var colsXS = this.getColumnsXS(title,types,maxValueActions,maxValueRecs)


    return (
          <Grid role="article" className='page-section explore-section-table'>
            <h1>{'Explore by ' + title}</h1>
            <EntityTableWrap
              ariaHidden="false"
              collapsible = {false}
              className="explore-table hidden-xs"
              cols = {cols}
              rows = {entities}
              entityType = {flux.store(category).getEntityType()}
              linked = {true}
            />
            <EntityTableWrap
              ariaHidden="true"
              collapsible = {false}
              className="explore-table visible-xs"
              cols = {colsXS}
              rows = {entities}
              entityType = {flux.store(category).getEntityType()}
              linked = {true}
            />
            <div className="table-note">
              <span className="text-uppercase strong">Note: </span>
              Actions and recommendations may not add up to totals due to multiple possible assignments
            </div>
          </Grid>
    )
  },
  // get category items
  getEntities : function (category,types) {
    var flux = this.getFlux()
    var maxValue = 0
    return _.map(flux.store(category).entities(),function(entity){

      if (types.indexOf('actions') > -1) {
        //get actions for issue, issue referenced by action
        entity.countActions = referencing(flux,{
          entity : entity,
          attr : category,
          from : 'actions'
        }).length
      }
      if (types.indexOf('recommendations') > -1) {
        entity.countRecs = referencing(flux,{
          entity : entity,
          attr : category,
          from : 'recommendations'
        }).length

        entity.countRecsAccepted = _.filter(referencing(flux,{
          entity : entity,
          attr : category,
          from : 'recommendations'
        }),function(item){
          return item.response === 'Accepted'
        }).length

        entity.countRecsNotAccepted =
           entity.countRecs - entity.countRecsAccepted
      }
      return entity
    })
  },

  // figure out maximum number of entities for given category
  getMaxCount : function(entities,types){
    var maxVal = 0
    _.each(entities,function(entity){
      if (types.indexOf('actions') > -1) {
        maxVal = Math.max(maxVal,entity.countActions)
      }
      if (types.indexOf('recommendations') > -1) {
        maxVal = Math.max(maxVal,entity.countRecs)
      }
    })
    return maxVal

  },

  // set up entity table columns
  getColumns : function(title, types, maxValue){
    var cols = []

    cols.push({
      type:   'text',
      title:  title,
      attr:   'title'
    })

    // action column if actions
    if(types.indexOf('actions') > -1) {
      cols.push({
          type:       'bar',
          units :     true,
          title:      'Government Actions',
          value :     {attr:'countActions',color:'#0095AC'},
          maxValue :  maxValue,
        })
    }

    // rec column if recs
    if (types.indexOf('recommendations') > -1) {
      cols.push({
          type:       'bar',
          stacked :   true,
          units :     true,
          title:      'UPR Recommendations',
          values :    [
            {attr:'countRecsAccepted',color:'#E19900',title:'Accepted'},
            {attr:'countRecsNotAccepted',color:'#AEBCC1',title:'Not accepted'}
          ],
          key : {
            type:'units',
            items: [{
                title:'Accepted',
                color:'#E19900'
              },
              {
                title:'Not Accepted',
                color:'#AEBCC1'
              }
            ]
          },
          maxValue :  maxValue,
        })
    }
    // key column if recs, else spacer
    cols.push({
      type: 'links'
    })


    return cols
  },
  // set up entity table columns
  getColumnsXS : function(title, types, maxValueActions, maxValueRecs){
    var cols = []
    cols.push({
      type:   'text',
      title:  title,
      attr:   'title'
    })

    if (types.indexOf('actions') > -1) {
      cols.push({
        type:       'bar',
        title:      'Actions',
        value :     {attr:'countActions',color:'#0095AC'},
        maxValue :  maxValueActions,
      })
    }
    // key column if recs and not actions, else spacer
    cols.push({
      type: 'links',
    })


    return cols
  }

})
