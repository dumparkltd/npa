var React       = require('react')
var Fluxxor     = require('fluxxor')
var StoreWatchMixin = Fluxxor.StoreWatchMixin

//components
var Load        = require('components/load')
var PageNotFound= require('components/page-not-found')

var FiltersPanel = require('components/filters/FiltersPanel')

// TODO TEMP
var EntityTableWrap            = require('components/table/EntityTableWrap')

// bootstrap
var Grid 				= require('react-bootstrap/lib/Grid')
var Row 				= require('react-bootstrap/lib/Row')
var Col 				= require('react-bootstrap/lib/Col')

//util
var referencing = require('utils/referencing')
var getColumns = require('utils/getColumns')
var checkSMART = require('utils/checkSMART')

//helpers
var _           = require('lodash')
var moment      = require('moment')
var log         = require('debug')('src:components:all')

module.exports = React.createClass({
  mixins: [
    Fluxxor.FluxMixin(React),
    StoreWatchMixin('actions','recommendations','issues','groups','agencies','treatybodies')
  ],
  propTypes : {
    params: React.PropTypes.object,
    query: React.PropTypes.object
  },
  getInitialState : function(){
    return {      
      types : {
        actions : [
          {by:'issue',type:'entities',attr:'issues',relation:'to',filtergroup:'cat',filterlabel:'Issues'},
          {by:'group',type:'entities',attr:'groups',relation:'to',filtergroup:'cat',filterlabel:'Groups'},
          {by:'agency',type:'entities',attr:'agencies',relation:'to',filtergroup:'cat',filterlabel:'Agencies'},
          {by:'specific',type:'smart',attr:'isspecific',filtergroup:'smart',filterlabel:'Specific'},
          {by:'measurable',type:'smart',attr:'ismeasurable',filtergroup:'smart',filterlabel:'Measurable'},
          {by:'assignable',type:'smart',attr:'isassignable',filtergroup:'smart',filterlabel:'Assignable'},
          {by:'resultoriented',type:'smart',attr:'isresultoriented',filtergroup:'smart',filterlabel:'Result-oriented'},
          {by:'timebound',type:'smart',attr:'istimebound',filtergroup:'smart',filterlabel:'Time-bound'},
          {by:'target-date-after',type:'date',attr:'targetdate', relation:'after',filtergroup:'date',filterlabel:'After'},
          {by:'target-date-before',type:'date',attr:'targetdate', relation:'before',filtergroup:'date',filterlabel:'Before'}
        ],
        recommendations : [
          {by:'issue',type:'entities',attr:'issues',relation:'to',filtergroup:'cat',filterlabel:'Issues'},
          {by:'group',type:'entities',attr:'groups',relation:'to',filtergroup:'cat',filterlabel:'Groups'},
          {by:'treatybody',type:'entities',attr:'treatybodies',relation:'to',filtergroup:'cat',filterlabel:'Treaty Bodies'},
          {by:'response',type:'text',attr:'response',filtergroup:'response',filterlabel:'Response'},
//          {by:'accepted',type:'response',attr:'response',filtergroup:'response',filterlabel:'Accepted'},
//          {by:'rejected',type:'response',attr:'response',filtergroup:'response',filterlabel:'Not Accepted'}
        ]          
      }
    }
  },
  getStateFromFlux: function () {
    var flux = this.getFlux()
    return {
      loading: flux.store('actions').isLoading() 
           ||  flux.store("recommendations").isLoading()
    }
  },

  render: function () {
    log('props',this.props)
     
    var flux = this.getFlux()
    
    var type = this.props.params.id
    var query = _.clone(this.props.query)
    
    // check if type is allowed
    if (Object.keys(this.state.types).indexOf(type) === -1)  {
              
      return ( 
        <PageNotFound />
      )
    } else if (this.state.loading) {
      return (
        <Load/>
      )
    } else {
      
      // the filter definitions
      var typeFilters = this.state.types[type]     
      
      // 'collect' conditions      
      var conditions = []
      // for each filter from query
      _.each(query,function(condition,key){
        // get filter definition from this.state[type]
        var typeFilter = _.find(typeFilters,{by:key})
        
        if (typeof typeFilter !== 'undefined') {
        
          if (typeFilter.type === 'entities') {
            if (_.isArray(condition)) {
              _.each(condition,function(singleCondition){
                conditions.push(this.entitiesCondition(typeFilter,singleCondition))
              },this)
            } else {
              conditions.push(this.entitiesCondition(typeFilter,condition))              
            }                                             

          } else if(typeFilter.type === 'smart') {
            if (_.isArray(condition)) {
              _.each(condition,function(singleCondition){
                conditions.push(this.smartCondition(typeFilter,singleCondition))
              },this)
            } else {
              conditions.push(this.smartCondition(typeFilter,condition))              
            }              
                        
          } else if(typeFilter.type === 'response') {
            conditions.push(this.responseCondition(typeFilter))  
            
          } else if(typeFilter.type === 'date') {
            if (typeFilter.relation === 'after') {
              conditions.push(this.dateAfterCondition(typeFilter,condition))
            } else if (typeFilter.relation === 'before') {
              conditions.push(this.dateBeforeCondition(typeFilter,condition))
            }

          } else {         
              conditions.push(this.textCondition(typeFilter,condition))
          }
        } 
//        else {
//          conditions.push(function(entity){      
//            return entity[key] === condition
//          })
//        }
      },this);
      
      
      
      // filter entities according to conditions      
      var filtered = conditions.length === 0 
        ? flux.stores[type].entities()
        : flux.stores[type].filter(function(item){        
          return conditions.length === 1 
            ? conditions[0](item)
            : _.reduce(conditions, function(bool, condition){          
              return (typeof bool === 'function' ? bool(item) : bool) && condition(item)
            })
          })
          

                
      return (
        <div role='main' >
          <FiltersPanel 
            type = {type}
            query = {query}
            filters = {typeFilters}
            entities = {filtered}
          />
          <div role='article' className="page-content page-content-all">
            <Grid className='page-section page-section-main'>
               {this.renderMain()}
            </Grid>
            <Grid className={'page-section page-section-' + type}>
              <EntityTableWrap
                caption = {filtered.length + ' Entitites (TODO)'}
                collapsible={false}  
                className={type + '-table'}
                linked = {true}
                cols = {getColumns(type, flux, filtered)}            
                rows = {filtered} 
                entityType = 'type'
              />
            </Grid>
          </div>
        </div>
      )
    }
  },
  entitiesCondition : function(typeFilter,condition){
    var flux = this.getFlux()
    return function(entity){      
      if (typeFilter.relation === 'to') {
        return entity[typeFilter.attr].indexOf(condition) > -1
      } else if (typeFilter.relation === 'from') {
        return flux.store(typeFilter.from).filter(function(item){
          return item.id === condition && item[typeFilter.attr].indexOf(entity.id) > -1
        }).length > 0                    
      }    
    }
  },
  smartCondition : function(typeFilter,condition){
    return function(entity){      
      return (condition === 'true' && checkSMART(entity[typeFilter.attr]))
          || (condition === 'false' && !checkSMART(entity[typeFilter.attr]))
    }
  },
  responseCondition : function(typeFilter){
    return function(entity){      
      return (typeFilter.by === 'accepted' && entity[typeFilter.attr] === 'Accepted')
          || (typeFilter.by === 'rejected' && entity[typeFilter.attr] === 'Rejected')
    }
  },
  textCondition : function(typeFilter,condition){
    return function(entity){      
      return entity[typeFilter.attr] === condition
    }
  },
  dateAfterCondition : function(typeFilter,condition){
    return function(entity){    
      var value = entity[typeFilter.attr]
      return value !== '' 
          && value.format() !== 'Invalid date'
          && value.isAfter(moment(condition,'MM-YYYY',true),'month')
    }
  },
  dateBeforeCondition : function(typeFilter,condition){
    return function(entity){     
      var value = entity[typeFilter.attr]
      return value !== '' 
          && value.format() !== 'Invalid date'
          && value.isBefore(moment(condition,'MM-YYYY',true),'month')
    }
  },
  renderMain : function (){
    var flux = this.getFlux()
    return (
      
        <Row key={0} className="header-row">
          <Col sm={12}>
          </Col>
        </Row>
           
    )
  },
  
      


 

})
