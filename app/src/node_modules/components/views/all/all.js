var React       = require('react')
var Fluxxor     = require('fluxxor')
var StoreWatchMixin = Fluxxor.StoreWatchMixin

//components
var Load        = require('components/load')
var PageNotFound= require('components/page-not-found')

var FiltersPanel = require('components/filters/FiltersPanel')

// TODO TEMP
var EntityListFactory = require('components/table/EntityListFactory')

// bootstrap
var Grid 				= require('react-bootstrap/lib/Grid')
var Row 				= require('react-bootstrap/lib/Row')
var Col 				= require('react-bootstrap/lib/Col')

//util
var referencing = require('utils/referencing')
var getColumns = require('utils/getColumns')
var checkSMART = require('utils/checkSMART')

//helpers
var _           = require('lodash')
var moment      = require('moment')
var log         = require('debug')('src:components:all')

module.exports = React.createClass({
  mixins: [
    Fluxxor.FluxMixin(React),
    StoreWatchMixin('actions','recommendations','issues','groups','agencies','treatybodies')
  ],
  propTypes : {
    params: React.PropTypes.object,
    query: React.PropTypes.object
  },
  getInitialState : function(){
    return {          
      filtergroups : {
        actions : [
          {
            rowid : 1, bydefault : true, title : '',
            groups : [
              { 
                group : 'cat', title : '', type:'multiselect', span:{sm:12},            
                filters : [
                  {by:'issue',type:'entities',attr:'issues',relation:'to',label:'Issue',placeholder:'Select Issue'},
                  {by:'group',type:'entities',attr:'groups',relation:'to',label:'Population Group',placeholder:'Select Group'},
                  {by:'agency',type:'entities',attr:'agencies',relation:'to',label:'Goverment Agency',placeholder:'Select Agency'}
                ]
              }
            ]
          },
          {
            rowid : 2, bydefault : false, title : 'SMART criteria', reset:true,
            groups : [
              { 
                group : 'specific', title : 'Specific', type:'icon',
                span:{xxs:6,xs:4,sm:2},
                filters : [       
                  {by:'specific',value:'true',type:'smart',attr:'isspecific',label:'Met',
                    options:[{value:'',icon:'smart-s-pass'},{value:'true',icon:'smart-s-pass-active'}]},
                  {by:'specific',value:'false',type:'smart',attr:'isspecific',label:'Not met', 
                    options:[{value:'',icon:'smart-s-fail'},{value:'false',icon:'smart-s-fail-active'}]},
                ]   
              },             
              { 
                group : 'measurable', title : 'Measurable', type:'icon',
                span:{xxs:6,xs:4,sm:2},
                filters : [       
                  {by:'measurable',value:'true',type:'smart',attr:'ismeasurable',label:'Met',
                    options:[{value:'',icon:'smart-m-pass'},{value:'true',icon:'smart-m-pass-active'}]},
                  {by:'measurable',value:'false',type:'smart',attr:'ismeasurable',label:'Not met', 
                    options:[{value:'',icon:'smart-m-fail'},{value:'false',icon:'smart-m-fail-active'}]},
                ]   
              },             
              { 
                group : 'assignable', title : 'Assignable', type:'icon',
                span:{xxs:6,xs:4,sm:2},
                filters : [       
                  {by:'assignable',value:'true',type:'smart',attr:'isassignable',label:'Met',
                    options:[{value:'',icon:'smart-a-pass'},{value:'true',icon:'smart-a-pass-active'}]},
                  {by:'assignable',value:'false',type:'smart',attr:'isassignable',label:'Not met', 
                    options:[{value:'',icon:'smart-a-fail'},{value:'false',icon:'smart-a-fail-active'}]},
                ]   
              },             
              { 
                group : 'resultoriented', title : 'Result-oriented', type:'icon',
                span:{xxs:6,xs:4,sm:2},
                filters : [       
                  {by:'resultoriented',value:'true',type:'smart',attr:'isresultoriented',label:'Met',
                    options:[{value:'',icon:'smart-r-pass'},{value:'true',icon:'smart-r-pass-active'}]},
                  {by:'resultoriented',value:'false',type:'smart',attr:'isresultoriented',label:'Not met', 
                    options:[{value:'',icon:'smart-r-fail'},{value:'false',icon:'smart-r-fail-active'}]},
                ]   
              },             
              { 
                group : 'timebound', title : 'Timebound', type:'icon',
                span:{xxs:6,xs:4,sm:2},
                filters : [       
                  {by:'timebound',value:'true',type:'smart',attr:'istimebound',label:'Met',
                    options:[{value:'',icon:'smart-t-pass'},{value:'true',icon:'smart-t-pass-active'}]},
                  {by:'timebound',value:'false',type:'smart',attr:'istimebound',label:'Not met', 
                    options:[{value:'',icon:'smart-t-fail'},{value:'false',icon:'smart-t-fail-active'}]},
                ]   
              }             
            ]
          },
          {
            rowid:3, bydefault:false, title:'Target date',reset:true,
            groups: [
              {
                group : 'date', title : 'After', type:'dateselect', 
                 span:{sm:3},
                 filters: [
                   {by:'target-date-after',type:'date',attr:'targetdate', relation:'after',placeholder:'Enter date'}
                 ]
              },
              {
                group : 'date', title : 'Before', type:'dateselect', 
                 span:{sm:3},
                 filters: [
                   {by:'target-date-before',type:'date',attr:'targetdate', relation:'before',placeholder:'Enter date'}              
                 ]
              }
            ]
          } 
        ],
        recommendations : [
          {
            rowid : 1, bydefault : true, title : '',
            groups : [
              { 
                group : 'cat', title : '', type:'multiselect', span:{sm:12},            
                filters: [
                  {by:'issue',type:'entities',attr:'issues',relation:'to',label:'Issue',placeholder:'Select Issue'},
                  {by:'group',type:'entities',attr:'groups',relation:'to',label:'Population Group',placeholder:'Select Group'},
                  {by:'treatybody',type:'entities',attr:'treatybodies',relation:'to',label:'UN Treaty Body',placeholder:'Select Treaty Body'}                    
                ]
              }
            ]
          },
          {
            rowid : 2, bydefault : false,
            groups : [                
              { 
                group : 'response', title : 'Government Response', type:'icon',
                span:{xs:6,sm:4},
                filters: [       
                  {by:'accepted',type:'response',attr:'response',label:'Accepted', 
                    options:[{value:'',icon:'pass'},{value:'true',icon:'pass-active'}]},
                  {by:'rejected',type:'response',attr:'response',label:'Not Accepted', 
                    options:[{value:'',icon:'fail'},{value:'true',icon:'fail-active'}]},
                ]              
              },              
              { 
                group : 'addressed', title : 'Addressed by Action(s)', type:'icon',
                span:{xs:6,sm:4},
                filters: [
                  {by:'addressed',type:'addressed',label:'Addressed', 
                    options:[{value:'',icon:'pass'},{value:'true',icon:'pass-active'}]},
                  {by:'notaddressed',type:'addressed',label:'Not Addressed', 
                    options:[{value:'',icon:'fail'},{value:'true',icon:'fail-active'}]},
                ]            
              }
                              
            ]
          }
        ]       
      }      
    }
  },
  getStateFromFlux: function () {
    var flux = this.getFlux()
    return {
      loading: flux.store('actions').isLoading()
           ||  flux.store("recommendations").isLoading()
    }
  },

  render: function () {
    log('props',this.props)

    var flux = this.getFlux()

    var type = this.props.params.id
    var query = _.clone(this.props.query)

    // check if type is allowed
    if (Object.keys(this.state.filtergroups).indexOf(type) === -1)  {              
      return ( 
        <PageNotFound />
      )
    } else if (this.state.loading) {
      return (
        <Load/>
      )
    } else {

      // grab the filter definitions from the different filter rows and groups
      var typeFilters = _(this.state.filtergroups[type]).pluck('groups').flatten(true).pluck('filters').flatten(true).value()

      // 'collect' conditions      
      var conditions = this.getConditions(query,typeFilters)
      
      
      // filter entities according to conditions      
      var filteredEntities = conditions.length === 0 
        ? flux.stores[type].entities()
        : flux.stores[type].filter(function(item){
          return conditions.length === 1
            ? conditions[0](item)
            : _.reduce(conditions, function(bool, condition){
              return (typeof bool === 'function' ? bool(item) : bool) && condition(item)
            })
          })
          
      // 1. Filters panel
      // 2. Filtered entity list
                
      return (
        <div role='main' >
          <section className='page-tools'>
            <FiltersPanel
              type = {type}
              query = {query}
              filterRows = {this.state.filtergroups[type]}
              entities = {filteredEntities}
            />
          </section>
          <div role='article' className="page-content page-content-all">
            <Grid className={'page-section page-section-' + type}>
              <EntityListFactory
                entities = {filteredEntities} 
                type = {type}
                showEmpty = {true}
                showCount = {true}
                collapsible={true}
                maxItems={20}
                linked = {true}     
                captionAttribute = {(conditions.length === 0 ? '' : 'Filtered ')} 
              />
            </Grid>
          </div>
        </div>
      )     
    }
  },
  getConditions : function (query,typeFilters) {
    
      
    // the filter conditions to test
    var conditions = []
      
    // for each filter from query
    _.each(query,function(condition,key){
      // get filter definition from this.state[type]
      var typeFilter = _.find(typeFilters,{by:key})

      if (typeof typeFilter !== 'undefined') {

        if (typeFilter.type === 'entities') {
          if (_.isArray(condition)) {
            _.each(condition,function(singleCondition){
              conditions.push(this.entitiesCondition(typeFilter,singleCondition))
            },this)
          } else {
            conditions.push(this.entitiesCondition(typeFilter,condition))              
          }                                             

        } else if(typeFilter.type === 'smart') {
          if (_.isArray(condition)) {
            _.each(condition,function(singleCondition){
              conditions.push(this.smartCondition(typeFilter,singleCondition))
            },this)
          } else {
            conditions.push(this.smartCondition(typeFilter,condition))              
          }              

        } else if(typeFilter.type === 'response') {
          conditions.push(this.responseCondition(typeFilter))  

        } else if(typeFilter.type === 'addressed') {
          conditions.push(this.addressedCondition(typeFilter))  

        } else if(typeFilter.type === 'date') {
          if (typeFilter.relation === 'after') {
            conditions.push(this.dateAfterCondition(typeFilter,condition))
          } else if (typeFilter.relation === 'before') {
            conditions.push(this.dateBeforeCondition(typeFilter,condition))
          }

        } else {         
            conditions.push(this.attributeCondition(typeFilter,condition))
        }
      } 
    },this);    
    return conditions
  },
  
  // define filter conditions
  // condition for related entities 
  entitiesCondition : function(typeFilter,condition){
    var flux = this.getFlux()
    return function(entity){
      if (typeFilter.relation === 'to') {
        return entity[typeFilter.attr].indexOf(condition) > -1
      } else if (typeFilter.relation === 'from') {
        return flux.store(typeFilter.from).filter(function(item){
          return item.id === condition && item[typeFilter.attr].indexOf(entity.id) > -1
        }).length > 0
      }
    }
  },
  // condition for smart criteria (action)
  smartCondition : function(typeFilter,condition){
    return function(entity){
      return (condition === 'true' &&  checkSMART(entity[typeFilter.attr]))          
          || (condition === 'false' && !checkSMART(entity[typeFilter.attr]))
    }
  },
  // condition for addressed criteria (recommendation)
  addressedCondition : function(typeFilter){
    var flux = this.getFlux()
    return function(entity){      
      var actions = referencing(flux, {
        entity : entity, // the recommendation
        attr : 'recommendations',
        from : 'actions'        
       })
      return (typeFilter.by === 'addressed' && actions.length > 0)
          || (typeFilter.by === 'notaddressed' && actions.length === 0)
    }
  },
  // condition for response criteria (recommendation)
  responseCondition : function(typeFilter){
    return function(entity){
      return (typeFilter.by === 'accepted' && entity[typeFilter.attr] === 'Accepted')
          || (typeFilter.by === 'rejected' && entity[typeFilter.attr] === 'Rejected')
    }
  },
  // condition for attribute
  attributeCondition : function(typeFilter,condition){
    return function(entity){      
      return entity[typeFilter.attr] === condition
    }
  },
  // date after condition
  dateAfterCondition : function(typeFilter,condition){
    return function(entity){
      var value = entity[typeFilter.attr]
      return value !== ''
          && value.format() !== 'Invalid date'
          && value.isAfter(moment(condition,'MM-YYYY',true),'month')
    }
  },
  // date before condition
  dateBeforeCondition : function(typeFilter,condition){
    return function(entity){
      var value = entity[typeFilter.attr]
      return value !== ''
          && value.format() !== 'Invalid date'
          && value.isBefore(moment(condition,'MM-YYYY',true),'month')
    }
  }
        



})
