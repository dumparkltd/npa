var React       = require('react')
var Fluxxor     = require('fluxxor')
var StoreWatchMixin = Fluxxor.StoreWatchMixin

//components
var Load        = require('components/load')
var PageNotFound= require('components/page-not-found')

// TEMP
var NavTop        = require('components/nav/nav-categories')
var EntityTableWrap            = require('components/table/EntityTableWrap')

// bootstrap
var Grid 				= require('react-bootstrap/lib/Grid')
var Row 				= require('react-bootstrap/lib/Row')
var Col 				= require('react-bootstrap/lib/Col')

//util
var referencing = require('utils/referencing')
var getColumns = require('utils/getColumns')

//helpers
var _           = require('lodash')
var log         = require('debug')('src:components:filter')

module.exports = React.createClass({
  mixins: [
    Fluxxor.FluxMixin(React),
    StoreWatchMixin('actions','recommendations','issues','groups','agencies','treatybodies')
  ],
  propTypes : {
    params: React.PropTypes.object,
    query: React.PropTypes.object
  },
  getInitialState : function(){
    return {
      targets : {
        actions : [
          {by:'issue',type:'entities',attr:'issues',relation:'to'},
          {by:'group',type:'entities',attr:'groups',relation:'to'},
          {by:'agency',type:'entities',attr:'agencies',relation:'to'},
          {by:'recommendation',type:'entities',attr:'recommendations',relation:'to'},
          {by:'targetdate_after',type:'date',attr:'targetdate', relation:'after'},
          {by:'targetdate_before',type:'date',attr:'targetdate', relation:'before'}
        ],
        recommendations : [
          {by:'issue',type:'entities',attr:'issues',relation:'to'},
          {by:'group',type:'entities',attr:'groups',relation:'to'},
          {by:'treatybody',type:'entities',attr:'treatybodies',relation:'to'},
          {by:'action',type:'entities',attr:'recommendations',relation:'from',from:'actions'},
          {by:'response',type:'text',attr:'response'}
        ]          
      }
    }
  },
  getStateFromFlux: function () {
    var flux = this.getFlux()
    return {
      loading: flux.store('actions').isLoading() 
           ||  flux.store("recommendations").isLoading()
    }
  },

  render: function () {
    log('props',this.props)
     
    var flux = this.getFlux()
    
    var target = this.props.params.id
    var filters = _.clone(this.props.query)
    
    // check if target is allowed
    if (Object.keys(this.state.targets).indexOf(target) === -1)  {
              
      return ( 
        <div>
          <NavTop />
          <PageNotFound />
        </div>
      )
    } else if (this.state.loading) {
      return (
        <div>
          <NavTop 
            active = 'actions'
          />  
          <Load/>
        </div>
      )
    } else {
      
      targetFilters = this.state.targets[target]
      
      // collect conditions
      
      var conditions = []
      // for each filter from filters
      _.each(filters,function(filter,key){
        // get filter definition from this.state[target]
        var targetFilter = _.find(targetFilters,{by:key})
        
        if (targetFilter.type === 'entities') {
          if (_.isArray(filter)) {
            _.each(filter,function(filterItem){
              conditions.push(this.entitiesCondition(targetFilter,filterItem))
            },this)
          } else {
            conditions.push(this.entitiesCondition(targetFilter,filter))              
          }            
          
          
        } else if(targetFilter.type === 'text') {
          
        
        } else if(targetFilter.type === 'date') {
        
        
        }
      },this);
      
      
      
      
      
      var entities = conditions.length === 0 
        ? flux.stores[target].entities()
        : flux.stores[target].filter(function(item){        
          return conditions.length === 1 
            ? conditions[0](item)
            : _.reduce(conditions, function(bool, condition){          
              return (typeof bool === 'function' ? bool(item) : bool) && condition(item)
            })
          })

                
      return (
        <div role='main' >
          <NavTop />              
                
          <div role='article' className="page-content-issue page-content">
            <Grid className='page-section issue-section-analysis'>
               {this.renderMain()}
            </Grid>
            <Grid className={'page-section page-section-' + target}>
              <EntityTableWrap
                caption = {entities.length + ' Entitites (TODO)'}
                collapsible={false}  
                className={target + '-table'}
                linked = {true}
                cols = {getColumns(target, flux, entities)}            
                rows = {entities} 
                entityType = 'target'
              />
            </Grid>
          </div>
        </div>
      )
    }
  },
  entitiesCondition : function(targetFilter,filterItem){
    var flux = this.getFlux()
    return function(entity){      
      if (targetFilter.relation === 'to') {
        return entity[targetFilter.attr].indexOf(filterItem) > -1
      } else if (targetFilter.relation === 'from') {
        return flux.store(targetFilter.from).filter(function(item){
          return item.id === filterItem && item[targetFilter.attr].indexOf(entity.id) > -1
        }).length > 0                    
      }    
    }
  },
  renderMain : function (){
    var flux = this.getFlux()
    return (
      
        <Row key={0} className="header-row">
          <Col sm={12}>
            <h5 className="header-type">TODO MAIN</h5>
          </Col>
        </Row>
           
    )
  },
  
      


 

})
