var React       = require('react')
var ReactDOM       = require('react-dom')
var Fluxxor     = require('fluxxor')
var StoreWatchMixin = Fluxxor.StoreWatchMixin
var DebounceInput = require('react-debounce-input')

//components
var Icon        = require('components/Icon')
var Load        = require('components/Load')
var PageNotFound= require('components/PageNotFound')
var FiltersPanel = require('components/filters/FiltersPanel')

var EntityListFactory = require('components/table/EntityListFactory')

// bootstrap
var Grid 				= require('react-bootstrap/lib/Grid')
var Row 				= require('react-bootstrap/lib/Row')
var Col 				= require('react-bootstrap/lib/Col')

//util
var referencing = require('utils/referencing')
var getColumns = require('utils/get-columns')
var checkSMART = require('utils/check-smart')

//helpers
var _           = require('lodash')
var moment      = require('moment')
var log         = require('debug')('src:components:search')

module.exports = React.createClass({
  mixins: [
    Fluxxor.FluxMixin(React),
    StoreWatchMixin('actions','recommendations','issues','groups','agencies','treatybodies','articles','faq','pages')
  ],
  propTypes : {
    params: React.PropTypes.object,
    query: React.PropTypes.object
  },
  getInitialState : function(){
    return {
      minStrLength : 3,
      hints : {
        initial : (<p>Please enter your search terms above.</p>),
        notfound : (
          <span>
            <p>We are sorry! Your search returned 0 results.</p>
            <p>Please try different search terms.</p>
          </span>
        ),
        notfoundActive : (
          <span>
            <p>We are sorry! Your search returned 0 results</p>
            <p>Please try different search terms or select a different result type</p>
          </span>
        ),
        short : (<p>Please continue entering your search terms above</p>)
      },
      types : [
        { type : 'actions', matchId:true },
        { type : 'recommendations', matchId:true },
        { type : 'issues'},
        { type : 'groups'},
        { type : 'agencies'},
        { type : 'treatybodies'},
        { type : 'pages', excludes:['intro'],
          nestedTypes : [
            { type : 'articles' },
            { type : 'faq', },
          ]
        }
      ]
    }
  },

  getStateFromFlux: function () {
    var flux = this.getFlux()
    return {
      loading: flux.store('actions').isLoading()
           ||  flux.store("recommendations").isLoading()
           ||  flux.store("issues").isLoading()
           ||  flux.store("groups").isLoading()
           ||  flux.store("agencies").isLoading()
           ||  flux.store("treatybodies").isLoading()
           ||  flux.store("faq").isLoading()
           ||  flux.store("articles").isLoading()
           ||  flux.store("pages").isLoading()
    }
  },

  render: function () {
    log('props',this.props)

    // check loading
    if (this.state.loading) {
      return (
        <Load/>
      )
    } else {
      var query = _.clone(this.props.query)
      var queryType = query.type
      //defaults
      var queryStr  = typeof query.str  !== 'undefined' ? query.str  : ''

      // search by for types
      var types = _.clone(this.state.types,true)
      var matchCount = 0
      var matches = {types:[],matchCount:0}
      if (queryStr.length > 0 ){
        matches = this.match(types, queryStr)
        types = matches.types
        matchCount = matches.matchCount
      } 
      // set active type
      var activeType
      if (typeof queryType !== 'undefined') {
        activeType = _.find(types,function(type){
          return type.type === queryType
        })
        // no results found
        if (typeof activeType === 'undefined') {
          activeType = {type:'undefined'}
        }
      } else {
        if (queryStr.length > 0 ){
          // default to first matching type
          activeType = _.find(types,function(type){
            return typeof type.matches !== 'undefined' ? type.matches.length > 0 : false
          })
          // no results found
          if (typeof activeType === 'undefined') {
            activeType = {type:'notfound'}
          }
        } else {
          activeType = {type:'undefined'}
        }
      }



      return (
        <div role='main' >
          {this.renderSearchField(queryStr)}
           <div role='article' className="page-content-search page-content">
              <Grid className='page-section'>                   
                <Row>
                  {
                    (matchCount > 0 || typeof queryType !== 'undefined' )
                      ? (
                          <Col sm={3} key='1'>
                            <h5 className='header-type'>By type</h5>
                            {this.renderTypes(types,activeType,queryType,queryStr)}                    
                          </Col>
                        ) 
                      : (null)
                  }
                  <Col sm={9} key='2'>
                    <h5 className='header-type'>
                      {(queryStr.length === 0 || (matchCount === 0 && this.state.minStrLength) ) ? 'Search' : 'Search Results'}
                    </h5>
                    {this.renderResults(types,activeType,queryType,queryStr, matchCount)}
                  </Col>
                </Row>
              </Grid>
          </div>
        </div>
      )
    }
  },

  renderResults : function(types, activeType, queryType, queryStr, matchCount) {
    var minStrLength = this.state.minStrLength

    // not searched:
    if (queryStr.length === 0) {
      // type set/not set:
      // initial hint
      return this.state.hints.initial

    } else {
    // searched:
      if (activeType.type !== 'notfound' && activeType.type !== 'undefined'){
        var results = (
          <EntityListFactory
            type = {activeType.type}
            entities = {activeType.matches}
            showEmpty = {true}
            showCount = {true}
            collapsible = {false}
            linked = {true}
            detailed = {false}
            captionAttribute = {' '}
            handleRowClick = {
              typeof activeType.clickHandler !== 'undefined'
                ? activeType.clickHandler
                : undefined
            }
          />
        )
      // results
        if (activeType.matches.length > 0) {
          return results
        }
        // no results
        else {
          // not found hint
          if (matchCount > 0 && typeof queryType !== 'undefined') {
            return (
              <div>
                {results}
                {this.state.hints.notfoundActive}
              </div>
            )
          } else {
            // min length:
            if (queryStr.length >= minStrLength) {
              return (
                <div>
                  {results}
                  {this.state.hints.notfound}
                </div>
              ) 
            } else {
              // length hint
              return (
                <div>
                  {results}
                  {this.state.hints.short}
                </div>
              )
            }
          }
        }
      } else {
        // min length:
          if (queryStr.length >= minStrLength) {
            // not found hint
            return this.state.hints.notfound
          } else {
            // length hint
            return this.state.hints.short
          }
      }
    }

  },
  renderTypes : function(types, activeType, queryType, queryStr) {
    var flux = this.getFlux()
    var minStrLength = this.state.minStrLength
    return (
      <ul className='list-unstyled result-types'>
      {
        _.map(types,function(type, key){
          var resultNo = typeof type.matches !== 'undefined' ? type.matches.length : 0
          var title = flux.stores[type.type].getTitle(2)
          
          if (type.type !== activeType.type && resultNo === 0) {
            return (
              <li key={key}>            
                <div className="no-results">
                  { title }
                  <span className='result-no'>{ resultNo }</span>
                </div>
              </li>
            )
          } else {
            var className = (type.type === activeType.type ? ' active' : '')
                  + (resultNo === 0 ? ' no-results' : '')
            return (
              <li key={key}>
                <a href="#" role='button'
                  className={className}
                  title={title + ': ' + resultNo}
                  onClick={this.handleTypeClick(type.type, activeType.type)}>
                    { title }
                    <span className='result-no'>{ resultNo }</span>
                </a>
              </li>
            )
          }
        },this)
      }
      </ul>
    )

  },
  renderSearchField : function (queryStr){
    var flux = this.getFlux()
    return (
      <section className='page-tools search-field-wrapper'>
        <Grid>
          <Row>
            <Col sm={12}>
              <Icon name='search'/>
              <DebounceInput
                className="search-field"
                placeholder="Search..." 
                autoFocus
                value={queryStr}
                minLength={1}
                debounceTimeout={300}
                onChange={this.handleInputChange} 
              />
              <a href="#" title="Clear Search" onClick={this.handleClearInput} className='btn-clear-search'>
                <Icon name="dismiss"/>
              </a>
            </Col>
          </Row>
        </Grid>
      </section>
    )
  },
  match : function(types, queryStr) {
    var flux = this.getFlux()
    var minStrLength = this.state.minStrLength
    
    // match multiple words
    // see http://stackoverflow.com/questions/5421952/how-to-match-multiple-words-in-regex
    var regex = ''    
    _.each(queryStr.split(' '), function(str){
      regex += '(?=.*\\b'+str+')'
    })    
    try {
      var pattern = new RegExp(regex, "i")
    
      var matchCount = 0
      _.each(types,function(type){

        type.matches = flux.stores[type.type].filter(function(item){
          if (typeof type.excludes !== 'undefined' && type.excludes.indexOf(item.id) > -1){
            return false
          } else {

            // test id          
            if (type.matchId && item.id === queryStr) {
              return true
            } else {
              if (queryStr.length >= minStrLength) {
                // target field
                var target = item.searchTarget                        
                // also concat nested type fileds
                if (typeof type.nestedTypes !== 'undefined' && item.entities !== '' ) {                
                  // get nested type 
                  var nestedType = _.find(type.nestedTypes,{'type':item.entities})                    
                  // get all nested items
                  _.each(flux.stores[nestedType.type].entities(),function(nestedItem){                                    
                    target += nestedItem.searchTarget                  
                  })                                
                }                
                return pattern.test(target)
              } else {
                return false
              }
            }

            return typeof matchField !== 'undefined' || matchNested
          }
        })
        matchCount += type.matches.length
      })
      return {types:types,matchCount:matchCount}
    } catch(e) {
      log('RegExFailure: '+queryStr)
      return {types:types,matchCount:0}
    }
  },
  handlePageLink :  function (page) {
    var flux = this.getFlux()

    return function (e) {
      // 13 = Return, 32 = Space
      if (typeof e.which === 'undefined' || e.which === 13 || e.which === 32) {
        e.preventDefault()
        flux.actions.navPage(page)
      }
    }
  },
  handleInputChange : function(e){
    this.getFlux().actions.query('str',e.target.value)
  },
  handleTypeClick : function(type, activeType) {
    return function (e) {
      e.preventDefault()
      if (type !== activeType) {
        this.getFlux().actions.query('type',type)
      } else {
        this.getFlux().actions.deleteFromQuery('type')
      }
    }.bind(this)
  },
  handleClearInput : function(e) {
    e.preventDefault()
    this.getFlux().actions.query('str','')
  }





})
