var React       = require('react')
var Fluxxor     = require('fluxxor')
var StoreWatchMixin = Fluxxor.StoreWatchMixin

//components
var Load        = require('components/load')
var PageNotFound= require('components/page-not-found')
var FiltersPanel = require('components/filters/FiltersPanel')

var EntityListFactory = require('components/table/EntityListFactory')

// bootstrap
var Grid 				= require('react-bootstrap/lib/Grid')
var Row 				= require('react-bootstrap/lib/Row')
var Col 				= require('react-bootstrap/lib/Col')

//util
var referencing = require('utils/referencing')
var getColumns = require('utils/getColumns')
var checkSMART = require('utils/checkSMART')

//helpers
var _           = require('lodash')
var moment      = require('moment')
var log         = require('debug')('src:components:search')

module.exports = React.createClass({
  mixins: [
    Fluxxor.FluxMixin(React),
    StoreWatchMixin('actions','recommendations','issues','groups','agencies','treatybodies','articles','faq','pages')
  ],
  propTypes : {
    params: React.PropTypes.object,
    query: React.PropTypes.object
  },
  getInitialState : function(){
    return {
      minStrLength : 3,
      hints : {
        initial : (<p>Please enter your search terms above.</p>),
        notfound : (
          [
            <p>We are sorry! Your search returned 0 results.</p>,
            <p>Please try different search terms.</p>
          ]
        ),
        notfoundActive : (
          [
            <p>We are sorry! Your search returned 0 results</p>,
            <p>Please try different search terms or select a different result type</p>
          ]
        ),
        short : (<p>Please continue entering your search terms above</p>)
      },
      types : [
        {
          type : 'actions',
          fields:['id','title','description','desiredoutcome','strategy','measures']
        },
        {
          type : 'recommendations',
          fields:['id','title','state','response','responsetext']
        },
        {
          type : 'issues',
          fields:['title','currentcontext','otherissuesraised']
        },
        {
          type : 'groups',
          fields:['title','commentary','description']
        },
        {
          type : 'agencies',
          fields:['title','description']
        },
        {
          type : 'treatybodies',
          fields:['title','about','concludingobservations']
        },
        {
          type : 'pages',
          exludes:['intro'],
          fields:['title','lead','description'],
          nestedTypes : [
            {
              type : 'articles',
              fields:['id','title','titlemaori']
            },
            {
              type : 'faq',
              fields:['question','answer']
            },
          ]
        }
      ]
    }
  },

  getStateFromFlux: function () {
    var flux = this.getFlux()
    return {
      loading: flux.store('actions').isLoading()
           ||  flux.store("recommendations").isLoading()
           ||  flux.store("issues").isLoading()
           ||  flux.store("groups").isLoading()
           ||  flux.store("agencies").isLoading()
           ||  flux.store("treatybodies").isLoading()
           ||  flux.store("faq").isLoading()
           ||  flux.store("articles").isLoading()
           ||  flux.store("pages").isLoading()
    }
  },

  render: function () {
    log('props',this.props)

    // check loading
    if (this.state.loading) {
      return (
        <Load/>
      )
    } else {
      var query = _.clone(this.props.query)
      var queryType = query.type
      //defaults
      var queryStr  = typeof query.str  !== 'undefined' ? query.str  : ''

      // search by for types
      var types = this.state.types
      if (queryStr.length > 0 ){
        types = this.match(types, queryStr)
      }
      // set active type
      var activeType
      if (typeof queryType !== 'undefined') {
        activeType = _.find(types,function(type){
          return type.type === queryType
        })
        // no results found
        if (typeof activeType === 'undefined') {
          activeType = {type:'undefined'}
        }
      } else {
        if (queryStr.length > 0 ){
          // default to first matching type
          activeType = _.find(types,function(type){
            return typeof type.matches !== 'undefined' ? type.matches.length > 0 : false
          })
          // no results found
          if (typeof activeType === 'undefined') {
            activeType = {type:'notfound'}
          }
        } else {
          activeType = {type:'undefined'}
        }
      }



      return (
        <div role='main' >
          {this.renderSearchField(queryStr)}
           <div role='article' className="page-content-search page-content">
              <Grid className='page-section'>
                <Row>
                  {
                    (queryStr.length > 0 || typeof queryType !== 'undefined')
                      ? (
                          <Col sm={3} smPush={9}>
                            <h5 className='header-type'>Select type</h5>
                            {this.renderTypes(types,activeType,queryType,queryStr)}
                          </Col>
                        )
                      : (null)
                  }
                  <Col sm={9} smPull={3}>
                    <h5 className='header-type'>
                      {(queryStr.length === 0 ) ? 'Search' : 'Search Results'}
                    </h5>
                    {this.renderResults(types,activeType,queryType,queryStr)}
                  </Col>
                </Row>
              </Grid>
          </div>
        </div>
      )
    }
  },

  renderResults : function(types, activeType, queryType, queryStr) {
    var minStrLength = this.state.minStrLength

    // not searched:
    if (queryStr.length === 0) {
      // type set/not set:
      // initial hint
      return this.state.hints.initial

    } else {
    // searched:
      if (activeType.type !== 'notfound' && activeType.type !== 'undefined'){
        var results = (
          <EntityListFactory
            type = {activeType.type}
            entities = {activeType.matches}
            showEmpty = {true}
            showCount = {true}
            collapsible = {false}
            linked = {true}
            detailed = {false}
            captionAttribute = {' '}
            handleRowClick = {
              typeof activeType.clickHandler !== 'undefined'
                ? activeType.clickHandler
                : undefined
            }
          />
        )
      // results
        if (activeType.matches.length > 0) {
          return results
        }
        // no results
        else {
          // not found hint
          if (typeof queryType !== 'undefined') {
            return [results,this.state.hints.notfoundActive]
          } else {
            // min length:
            if (queryStr.length >= minStrLength) {
              return [results,this.state.hints.notfound]
            } else {
              // length hint
              return [results,this.state.hints.short]
            }
          }
        }
      } else {
        // min length:
          if (queryStr.length >= minStrLength) {
            // not found hint
            return this.state.hints.notfound
          } else {
            // length hint
            return this.state.hints.short
          }
      }
    }

  },
  renderTypes : function(types, activeType, queryType, queryStr) {
    var flux = this.getFlux()
    var minStrLength = this.state.minStrLength
    return (
      <ul className='list-unstyled result-types'>
      {
        _.map(types,function(type){
          var resultNo = typeof type.matches !== 'undefined' ? type.matches.length : 0
          var className = (type.type === activeType.type ? ' active' : '')
                  + (resultNo === 0 ? ' disabled' : '')
          var title = flux.stores[type.type].getTitle(2)
          return (
            <li>
              <a href="#" role='button'
                className={className}
                onClick={this.handleTypeClick(type.type, activeType.type)}>
                  { title }
                  <span className='result-no'>{ resultNo }</span>
              </a>
            </li>
          )
        },this)
      }
      </ul>
    )

  },
  renderSearchField : function (queryStr){
    var flux = this.getFlux()
    return (
      <section className='page-tools search-field-wrapper'>
        <Grid>
          <Row>
            <Col sm={12}>
              <input
                className="search-field icon-magnifier"
                type="text"
                value={queryStr}
                placeholder="Search..."
                onChange={this.handleInputChange}
              />
              <i className="icon-close-small" onClick={this.handleClearInput}/>
            </Col>
          </Row>
        </Grid>
      </section>
    )
  },
  match : function(types, queryStr) {
    var flux = this.getFlux()
    var minStrLength = this.state.minStrLength
    var pattern = new RegExp(queryStr, "i")

    _.each(types,function(type){
      // consider checking for type match, eg when searched for "action" return all actions


      type.matches = flux.stores[type.type].filter(function(item){
        if (typeof type.exludes !== 'undefined' && type.exludes.indexOf(item.id) > -1){
          return false
        } else {
          // until first field matches
          var matchField = _.find(type.fields,function(field){
            if (field === 'id') {
              return item[field] === queryStr
            } else {
              if (queryStr.length >= minStrLength) {
                var target = item[field]
                        .replace(/[āĀ]/, "a")
                        .replace(/[ēĒ]/, "e")
                        .replace(/[īĪ]/, "i")
                        .replace(/[ōŌ]/, "o")
                        .replace(/[ūŪ]/, "u")
                return pattern.test(target)
              } else {
                return false
              }
            }
          })
          if (typeof type.nestedTypes !== 'undefined') {
            var matchNested = false
            _.each(type.nestedTypes,function(t){

              t.matches = flux.stores[t.type].filter(function(item){
                // until first field matches
                var matchField = _.find(t.fields,function(field){
                  if (field === 'id') {
                    return item[field] === queryStr
                  } else {
                    if (queryStr.length >= minStrLength) {
                      var target = item[field]
                              .replace(/[āĀ]/, "a")
                              .replace(/[ēĒ]/, "e")
                              .replace(/[īĪ]/, "i")
                              .replace(/[ōŌ]/, "o")
                              .replace(/[ūŪ]/, "u")
                      return pattern.test(target)
                    } else {
                      return false
                    }
                  }
                })
                return typeof matchField !== 'undefined'

              })
              matchNested = typeof t.matches !== 'undefined' && t.matches.length > 0
            })
          }
          return typeof matchField !== 'undefined' || matchNested
        }
      })

    })
    return types
  },
  handlePageLink :  function (page) {
    var flux = this.getFlux()

    return function (e) {
      // 13 = Return, 32 = Space
      if (typeof e.which === 'undefined' || e.which === 13 || e.which === 32) {
        e.preventDefault()
        flux.actions.navPage(page)
      }
    }
  },
  handleInputChange : function(e) {
    this.getFlux().actions.query('str',e.target.value)
  },
  handleTypeClick : function(type, activeType) {
    return function (e) {
      e.preventDefault()
      if (type !== activeType) {
        this.getFlux().actions.query('type',type)
      } else {
        this.getFlux().actions.deleteFromQuery('type')
      }
    }.bind(this)
  },
  handleClearInput : function(e) {
    this.getFlux().actions.query('str','')
  }





})
