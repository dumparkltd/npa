var React       = require('react')
var ReactDOM       = require('react-dom')
var Fluxxor     = require('fluxxor')
var StoreWatchMixin = Fluxxor.StoreWatchMixin

//components
var Load        = require('components/load')
var PageNotFound= require('components/page-not-found')
var FiltersPanel = require('components/filters/FiltersPanel')

var EntityListFactory = require('components/table/EntityListFactory')

// bootstrap
var Grid 				= require('react-bootstrap/lib/Grid')
var Row 				= require('react-bootstrap/lib/Row')
var Col 				= require('react-bootstrap/lib/Col')

//util
var referencing = require('utils/referencing')
var getColumns = require('utils/getColumns')
var checkSMART = require('utils/checkSMART')

//helpers
var _           = require('lodash')
var moment      = require('moment')
var log         = require('debug')('src:components:search')

module.exports = React.createClass({
  mixins: [
    Fluxxor.FluxMixin(React),
    StoreWatchMixin('actions','recommendations','issues','groups','agencies','treatybodies','articles','faq','pages')
  ],
  propTypes : {
    params: React.PropTypes.object,
    query: React.PropTypes.object
  },
  shouldComponentUpdate: function(nextProps, nextState) {
    return this.state.selectionStart === nextState.selectionStart
  },
  componentDidUpdate : function(){
    if (typeof this.refs.searchField !== 'undefined') {     
      var node = ReactDOM.findDOMNode(this.refs.searchField)
      var length = typeof this.props.query.str !== 'undefined' ? this.props.query.str.length : 0
      var cursor = this.state.selectionStart === -1 ? length : this.state.selectionStart
      node.focus()
      node.setSelectionRange(cursor, cursor)      
    }
  },
  getInitialState : function(){
    return {
      selectionStart : -1,
      minStrLength : 3,
      hints : {
        initial : (<p>Please enter your search terms above.</p>),
        notfound : (
          [
            <p>We are sorry! Your search returned 0 results.</p>,
            <p>Please try different search terms.</p>
          ]
        ),
        notfoundActive : (
          [
            <p>We are sorry! Your search returned 0 results</p>,
            <p>Please try different search terms or select a different result type</p>
          ]
        ),
        short : (<p>Please continue entering your search terms above</p>)
      },
      types : [
        {
          type : 'actions',
          fields:['id','title','description','desiredoutcome','strategy','measures']
        },
        {
          type : 'recommendations',
          fields:['id','title','state','response','responsetext']
        },
        {
          type : 'issues',
          fields:['title','currentcontext','otherissuesraised']
        },
        {
          type : 'groups',
          fields:['title','commentary','description']
        },
        {
          type : 'agencies',
          fields:['title','description']
        },
        {
          type : 'treatybodies',
          fields:['title','about','concludingobservations']
        },
        {
          type : 'pages',
          excludes:['intro'],
          fields:['title','lead','description'],
          nestedTypes : [
            {
              type : 'articles',
              fields:['id','title']
            },
            {
              type : 'faq',
              fields:['question','answer']
            },
          ]
        }
      ]
    }
  },

  getStateFromFlux: function () {
    var flux = this.getFlux()
    return {
      loading: flux.store('actions').isLoading()
           ||  flux.store("recommendations").isLoading()
           ||  flux.store("issues").isLoading()
           ||  flux.store("groups").isLoading()
           ||  flux.store("agencies").isLoading()
           ||  flux.store("treatybodies").isLoading()
           ||  flux.store("faq").isLoading()
           ||  flux.store("articles").isLoading()
           ||  flux.store("pages").isLoading()
    }
  },

  render: function () {
    log('props',this.props)

    // check loading
    if (this.state.loading) {
      return (
        <Load/>
      )
    } else {
      var query = _.clone(this.props.query)
      var queryType = query.type
      //defaults
      var queryStr  = typeof query.str  !== 'undefined' ? query.str  : ''

      // search by for types
      var types = _.clone(this.state.types)
      var matchCount = 0
      if (queryStr.length > 0 ){
        var matches = this.match(types, queryStr)
        types = matches.types
        matchCount = matches.matchCount
      }
      // set active type
      var activeType
      if (typeof queryType !== 'undefined') {
        activeType = _.find(types,function(type){
          return type.type === queryType
        })
        // no results found
        if (typeof activeType === 'undefined') {
          activeType = {type:'undefined'}
        }
      } else {
        if (queryStr.length > 0 ){
          // default to first matching type
          activeType = _.find(types,function(type){
            return typeof type.matches !== 'undefined' ? type.matches.length > 0 : false
          })
          // no results found
          if (typeof activeType === 'undefined') {
            activeType = {type:'notfound'}
          }
        } else {
          activeType = {type:'undefined'}
        }
      }



      return (
        <div role='main' >
          {this.renderSearchField(queryStr)}
           <div role='article' className="page-content-search page-content">
              <Grid className='page-section'>                   
                <Row>
                  {
                    (matchCount > 0 && (queryStr.length > 0 || typeof queryType !== 'undefined'))
                      ? (
                          <Col sm={3} key='1'>
                            <h5 className='header-type'>By type</h5>
                            {this.renderTypes(types,activeType,queryType,queryStr)}
                          </Col>
                        ) 
                      : (null)
                  }
                  <Col sm={9} key='2'>
                    <h5 className='header-type'>
                      {(queryStr.length === 0 || (matchCount === 0 && this.state.minStrLength) ) ? 'Search' : 'Search Results'}
                    </h5>
                    {this.renderResults(types,activeType,queryType,queryStr, matchCount)}
                  </Col>
                </Row>
              </Grid>
          </div>
        </div>
      )
    }
  },

  renderResults : function(types, activeType, queryType, queryStr, matchCount) {
    var minStrLength = this.state.minStrLength

    // not searched:
    if (queryStr.length === 0) {
      // type set/not set:
      // initial hint
      return this.state.hints.initial

    } else {
    // searched:
      if (activeType.type !== 'notfound' && activeType.type !== 'undefined'){
        var results = (
          <EntityListFactory
            type = {activeType.type}
            entities = {activeType.matches}
            showEmpty = {true}
            showCount = {true}
            collapsible = {false}
            linked = {true}
            detailed = {false}
            captionAttribute = {' '}
            handleRowClick = {
              typeof activeType.clickHandler !== 'undefined'
                ? activeType.clickHandler
                : undefined
            }
          />
        )
      // results
        if (activeType.matches.length > 0) {
          return results
        }
        // no results
        else {
          // not found hint
          if (matchCount > 0 && typeof queryType !== 'undefined') {
            return [results,this.state.hints.notfoundActive]
          } else {
            // min length:
            if (queryStr.length >= minStrLength) {
              return [results,this.state.hints.notfound]
            } else {
              // length hint
              return [results,this.state.hints.short]
            }
          }
        }
      } else {
        // min length:
          if (queryStr.length >= minStrLength) {
            // not found hint
            return this.state.hints.notfound
          } else {
            // length hint
            return this.state.hints.short
          }
      }
    }

  },
  renderTypes : function(types, activeType, queryType, queryStr) {
    var flux = this.getFlux()
    var minStrLength = this.state.minStrLength
    return (
      <ul className='list-unstyled result-types'>
      {
        _.map(types,function(type, key){
          var resultNo = typeof type.matches !== 'undefined' ? type.matches.length : 0
          var className = (type.type === activeType.type ? ' active' : '')
                  + (resultNo === 0 ? ' disabled' : '')
          var title = flux.stores[type.type].getTitle(2)
          return (
            <li key={key}>
              <a href="#" role='button'
                className={className}
                title={title + ': ' + resultNo}
                onClick={this.handleTypeClick(type.type, activeType.type)}>
                  { title }
                  <span className='result-no'>{ resultNo }</span>
              </a>
            </li>
          )
        },this)
      }
      </ul>
    )

  },
  renderSearchField : function (queryStr){
    var flux = this.getFlux()
    return (
      <section className='page-tools search-field-wrapper'>
        <Grid>
          <Row>
            <Col sm={12}>
              <input
                className="search-field icon-magnifier"
                type="text"
                value={queryStr}
                ref='searchField'
                placeholder="Search..."
                onChange={this.handleInputChange}
              />
              <a href="#" title="Clear Search" className="icon-close-small" onClick={this.handleClearInput}/>
            </Col>
          </Row>
        </Grid>
      </section>
    )
  },
  match : function(types, queryStr) {
    var flux = this.getFlux()
    var minStrLength = this.state.minStrLength
    
    // match multiple words
    // see http://stackoverflow.com/questions/5421952/how-to-match-multiple-words-in-regex
    var regex = ''    
    _.each(queryStr.split(' '), function(str){
      regex += '(?=.*\\b'+str+')'
    })
    
    var pattern = new RegExp(regex, "i")
    
    var matchCount = 0
    _.each(types,function(type){
      // consider checking for type match, eg when searched for "action" return all actions


      type.matches = flux.stores[type.type].filter(function(item){
        if (typeof type.excludes !== 'undefined' && type.excludes.indexOf(item.id) > -1){
          return false
        } else {
          
          // test id          
          if (_.indexOf(type.fields,'id') >= 0 && item.id === queryStr) {
            return true
          } else {
            if (queryStr.length >= minStrLength) {
              // concat target fields
              var target = ''          
              _.each(type.fields,function(field){
                target += item[field]
                  .replace(/[āĀ]/, "a")
                  .replace(/[ēĒ]/, "e")
                  .replace(/[īĪ]/, "i")
                  .replace(/[ōŌ]/, "o")
                  .replace(/[ūŪ]/, "u")
                target += ' '
              })
              // also concat nested type fileds
              if (typeof type.nestedTypes !== 'undefined' && item.entities !== '' ) {
                
                // get nested type 
                var nestedType = _.find(type.nestedTypes,{'type':item.entities})    
                
                // get all nested items
                var nestedItems = flux.stores[nestedType.type].entities()
                _.each(nestedItems,function(nestedItem){
                  _.each(nestedType.fields,function(field){                  
                    target += nestedItem[field]
                      .replace(/[āĀ]/, "a")
                      .replace(/[ēĒ]/, "e")
                      .replace(/[īĪ]/, "i")
                      .replace(/[ōŌ]/, "o")
                      .replace(/[ūŪ]/, "u")
                    target += ' '
                  })
                })                                
              }
                
              return pattern.test(target)
            } else {
              return false
            }
          }
     
          return typeof matchField !== 'undefined' || matchNested
        }
      })
      matchCount += type.matches.length
    })
    return {types:types,matchCount:matchCount}
  },
  handlePageLink :  function (page) {
    var flux = this.getFlux()

    return function (e) {
      // 13 = Return, 32 = Space
      if (typeof e.which === 'undefined' || e.which === 13 || e.which === 32) {
        e.preventDefault()
        flux.actions.navPage(page)
      }
    }
  },
  handleInputChange : function(e) {
    
    //remember cursor position
    this.setState(
      {'selectionStart': e.target.selectionStart}      
    )    
    this.getFlux().actions.query('str',e.target.value)
  },
  handleTypeClick : function(type, activeType) {
    return function (e) {
      e.preventDefault()
      if (type !== activeType) {
        this.getFlux().actions.query('type',type)
      } else {
        this.getFlux().actions.deleteFromQuery('type')
      }
    }.bind(this)
  },
  handleClearInput : function(e) {
    e.preventDefault()
    this.getFlux().actions.query('str','')
  }





})
