var React       = require('react')
var Fluxxor     = require('fluxxor')
var StoreWatchMixin = Fluxxor.StoreWatchMixin

//components
var Load        = require('components/load')

// widgets
Multiselect = require('react-widgets/lib/Multiselect')
SelectList = require('react-widgets/lib/SelectList')
DateTimePicker  = require('react-widgets/lib/DateTimePicker')

// bootstrap
var Grid 				= require('react-bootstrap/lib/Grid')
var Row 				= require('react-bootstrap/lib/Row')
var Col 				= require('react-bootstrap/lib/Col')

//utils
var parseDate   = require('utils/parseDate')

//helpers
var _           = require('lodash')
var moment      = require('moment')
var momentLocalizer = require('react-widgets/lib/localizers/moment')
momentLocalizer(moment);

var log         = require('debug')('src:components:categoryList')

var FiltersPanel = React.createClass({
  mixins: [
    Fluxxor.FluxMixin(React),
    StoreWatchMixin('actions','recommendations','issues','groups','agencies','treatybodies')

  ],
  propTypes : {
    type : React.PropTypes.string,
    query : React.PropTypes.object,
    filtergroups: React.PropTypes.array,
    entities : React.PropTypes.array
  },
  getInitialState : function(){
    return {
      showFilters: false,
      timestamp : new Date().getTime()
    }
  },
  getStateFromFlux: function () {
    var flux = this.getFlux()
    return {
      loading: {
        actions : flux.store('actions').isLoading()
           ||  flux.store("recommendations").isLoading()
           ||  flux.store("issues").isLoading()
           ||  flux.store("groups").isLoading()
           ||  flux.store("agencies").isLoading(),
        recommendations : flux.store('actions').isLoading()
           ||  flux.store("recommendations").isLoading()
           ||  flux.store("issues").isLoading()
           ||  flux.store("groups").isLoading()
           ||  flux.store("treatybodies").isLoading()
      }

    }
  },
  render: function () {
    log('props',this.props)

    if (this.state.loading[this.props.type]) {
      return (
          <Load/>
      )
    } else {

      if (!this.state.showFilters){
        return (
          <Grid className='hrc-filter-panel-wrapper hrc-filter-inactive' fluid={true}>
                <a href='#' className='hrc-filter-toggle' onClick={this.toggleFilters()}>Show filters <i className='icon-filter'/></a>
          </Grid>
        )
      } else {

        return (
          <div className='hrc-filter-panel-wrapper'>
            <a href='#' className='hrc-filter-toggle' onClick={this.toggleFilters()}>Close filter <i className='icon-filter'/></a>
            <Grid className='hrc-filter-panel hrc-filter-active'>
              <Row className='hrc-filter-wrapper'>
                <Col sm={11}>
                  <Row>
                    {
                      _.map(this.props.filtergroups, function(group, i){
                        var width = Math.max(20,100/group.filters.length)

                        // check if any filters are set for filtergroup
                        var groupFiltered = _.intersection (_.pluck(group.filters,'by'),Object.keys(this.props.query)).length > 0

                        return (
                          <Col className={'hrc-filter-group hrc-filter-group-'+ group.group} xs={group.span.xs} sm={group.span.sm} key={i}>
                            {group.title !== '' ? (<h5>{group.title}</h5>) : null}
                            {groupFiltered ? (<a className='hrc-filter-group-reset' href='#' onClick={this.handleGroupReset(group)}>Reset</a>) : null}
                            {
                              _.map(group.filters,function(filter,i){
                                return (
                                  <div
                                    className={"hrc-filter-component hrc-filter-component-by" + filter.by + " hrc-filter-component-type" + filter.type }
                                    style={{width:width + '%',display:'inline-block'}}
                                    key={i}>
                                      {this.getFilterComponent(group,filter,i)}
                                  </div>
                                )

                              },this)
                            }
                          </Col>
                        )
                      },this)
                    }
                  </Row>
                </Col>
              </Row>
              <div className="hrc-filter-toggle-bottom visible-xs">
                <a href='#' className='hrc-filter-toggle btn' onClick={this.toggleFilters()}>Close filter</a>
              </div>
            </Grid>
          </div>
        )
      }
    }
  },
  getFilterComponent : function(group,filter,i){
    var component

    var flux = this.getFlux()
    var query = this.props.query
    var entities = this.props.entities

    switch (group.type) {
      case 'icon' :
        var currentIndex, currentOption
        // figure out current option and next (onclick) option
        _.each(group.options,function(option,index){
          var currentValue = typeof query[filter.by] !== 'undefined' ? query[filter.by] : ''
          if (option.value === currentValue){
            currentIndex = index
            currentOption = option
          }
        })
        var nextIndex = ((currentIndex + 1) < group.options.length)
          ? (currentIndex + 1)
          : (currentIndex + 1) - group.options.length

        var nextOption = group.options[ nextIndex ]
        component = (
          <span className='filter-component-icon'>
            <a href='#' onClick={this.handleIconClick(filter.by, nextOption.value)}>
              <span role="img" className={filter.icons[currentIndex] + " icon"}></span>
              <div className={"filter-component-icon-text " + currentOption.value + " " + filter.label.replace(' ', '-' )}>{currentOption.prefix + filter.label}</div>
            </a>
          </span>
        )

        break

      case 'dateselect' :
        // calendar dropdown
        component =  (
          <span className='filter-component-dateselect'>
            <DateTimePicker
              key={new Date().getTime()}
              value={typeof query[filter.by] !== 'undefined'
                ? moment(query[filter.by],'MM-YYYY').toDate()
                : null
              }
              placeholder={filter.placeholder}
              initialView={"year"}
              finalView={"year"}
              format={"MMMM YYYY"}
              time={false}
              parse = {function(str){
                  return str !== '' ? parseDate(str) : str
              }}
              onChange = {_.bind(function(date) {
                var date_str = date !== '' ? moment(date).format('MM-YYYY') : date
                this.handleDateChange(filter.by, date_str)
              },this)}
            />
          </span>
        )
        break
      case 'multiselect' :
        // get options
        var options = []
        // if filter.type entities
        if (filter.type === 'entities') {
          // get all possible options for entities[filters.attr]
          if (filter.relation === 'to') {
            // get flattened list of all values referencing a related entity (to-relation)
            var referencing = _(entities).pluck(filter.attr).flatten().uniq().value()
            // filter referenced items by referencing list
            options = _.sortBy(flux.stores[filter.attr].filter(function(item){
              return _.contains(referencing,item.id)
            }),'title')
          } else if (filter.relation === 'from') {
            // NOT USED made for recommendations by actions

            // get flattened list of ids that may be referenced by a related entity (from relation)
            var referenced = _(entities).pluck('id').flatten().value()
            // filter referencing items (eg actions) by referenced list (eg recommendations)
            options = _.sortBy(flux.stores[filter.from].filter(function(item){
              return _.reduce(referenced, function(bool, referencedItem){
                var test = function(referencedItem) {return _.contains(item[filter.attr], referencedItem)}
                return ( typeof bool === 'string' ? test(bool) : bool ) || test(referencedItem)
              })
            }),'title')
          }
        }

        var label
        if (i === 0) {
          label = (
            <span className='filter-label'>
              <span className='filter-label-light'>
                {'Filter ' + flux.store(this.props.type).getTitle(entities.length) + ' by '}
              </span>
              <span className='filter-label-bold strong'>
                {filter.label}
              </span>
            </span>
          )
        } else {
          label = (
            <span className='filter-label'>
              <span className='filter-label-light'>by </span>
              <span className='filter-label-bold strong'>
                {filter.label}
              </span>
            </span>
          )
        }

        var values = []
        var referencing = typeof query[filter.by] === 'string' ? [query[filter.by]] : query[filter.by]
        // filter referenced items by referencing list
        values = _.sortBy(flux.stores[filter.attr].filter(function(item){
          return _.contains(referencing,item.id)
        }),'title')

        component = (
          <span className='filter-component-multiselect'>
            {label}
            <Multiselect
              key={new Date().getTime()}
              valueField='id'
              textField='title'
              value={values}
              data={options}
              filter='contains'
              placeholder = {filter.placeholder}
              onChange = {_.bind(function(values) {
                  this.handleMultiSelectChange(filter.by, _.pluck(values,'id'))
                },this)}
            />
          </span>
        )
        break
    }

    return component


  },
  handleIconClick : function(filter,value) {
    log('handleIconClick',filter )
    var self = this
    return function (e) {
      e.preventDefault()
      self.getFlux().actions.query(filter,value)
    }
  },
  handleMultiSelectChange : function(filter,ids) {
    log('handleMultiSelectChange',filter )
    this.getFlux().actions.multiselect(filter,ids)
  },
  handleDateChange : function(filter,date_str) {
    log('handleDateChange',filter )
    this.getFlux().actions.date(filter,date_str)
  },
  handleGroupReset : function(group) {
    log('handleGroupReset',group.group )
    var self = this
    return function (e) {
      e.preventDefault()
      self.getFlux().actions.deleteFromQuery(_.pluck(group.filters,'by'))
    }
  },
  toggleFilters: function () {
    var self = this
    return function (e) {
      e.preventDefault()
      self.setState({ showFilters: !self.state.showFilters })
    }
  }
})

module.exports = FiltersPanel;
