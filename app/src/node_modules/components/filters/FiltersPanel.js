var React       = require('react')
var Fluxxor     = require('fluxxor')
var StoreWatchMixin = Fluxxor.StoreWatchMixin

//components
var Load        = require('components/load')

// widgets
Multiselect = require('react-widgets/lib/Multiselect')
SelectList = require('react-widgets/lib/SelectList')
DateTimePicker  = require('react-widgets/lib/DateTimePicker')

// bootstrap
var Grid 				= require('react-bootstrap/lib/Grid')
var Row 				= require('react-bootstrap/lib/Row')
var Col 				= require('react-bootstrap/lib/Col')

//helpers
var _           = require('lodash')
var moment      = require('moment')
var log         = require('debug')('src:components:categoryList')

var FiltersPanel = React.createClass({
  mixins: [
    Fluxxor.FluxMixin(React),
    StoreWatchMixin('actions','recommendations','issues','groups','agencies','treatybodies')
    
  ],
  propTypes : {
    type : React.PropTypes.string,
    query : React.PropTypes.object,
    filters: React.PropTypes.array,
    entities : React.PropTypes.array
  },
  getInitialState : function(){
    return {
      filtergroups : {
        cat:      {title:'Categories',type:'multiselect',display:'block'},     
        smart:    {title:'SMART criteria',type:'icon',options:[
            {title:'Satisfied',value:'true'},
            {title:'Not satisfied',value:'false'}
        ],display:'inline-block'},        
        response: {title:'Government response',type:'icon',options:[
            {title:'Accepted',value:'Accepted'},
            {title:'Not accepted',value:'Rejected'}
        ],display:'inline-block'},
        date:     {title:'Target date',type:'dateselect',display:'inline-block'}
      }
    }
  },  
  getStateFromFlux: function () {
    var flux = this.getFlux()
    return {
      loading: {
        actions : flux.store('actions').isLoading() 
           ||  flux.store("recommendations").isLoading()
           ||  flux.store("issues").isLoading()
           ||  flux.store("groups").isLoading()
           ||  flux.store("agencies").isLoading(),
        recommendations : flux.store('actions').isLoading() 
           ||  flux.store("recommendations").isLoading()
           ||  flux.store("issues").isLoading()
           ||  flux.store("groups").isLoading()
           ||  flux.store("treatybodies").isLoading()
      }
           
    }
  },  
  render: function () {    
    log('props',this.props)
      
    var flux = this.getFlux();

    var type = this.props.type
    var query = this.props.query
    var filters = this.props.filters
    var entities = this.props.entities
      
    if (this.state.loading[type]) {
      return (
          <Load/>
      )
    } else {    

      var timestamp = new Date().getTime()

      // the filter components
      var filtergroups = {}
      _.each(this.state.filtergroups,function(group,key){
        if (_.contains(_(filters).pluck('filtergroup').uniq().value(),key)) {
          filtergroups[key] = group 
          filtergroups[key]['filters'] = []
        }
      })
      
      // for each filter figure out options and components
      _.each(filters,function(filter){        
        
        // get options
        // if filter.type entities
        if (filter.filtergroup === 'cat') {                   
          // get all possible options for entities[filters.attr]         
          if (filter.relation === 'to') {
            // get flattened list of all values referencing a related entity (to-relation)
            var referencing = _(entities).pluck(filter.attr).flatten().uniq().value()
            // filter referenced items by referencing list
            filter.options = _.sortBy(flux.stores[filter.attr].filter(function(item){
              return _.contains(referencing,item.id)
            }),'title')  
            
          } else if (filter.relation === 'from') {
            // NOT USED made for recommendations by actions
            
            // get flattened list of ids that may be referenced by a related entity (from relation)
            var referenced = _(entities).pluck('id').flatten().value()
            // filter referencing items (eg actions) by referenced list (eg recommendations)
            filter.options = _.sortBy(flux.stores[filter.from].filter(function(item){
              return _.reduce(referenced, function(bool, referencedItem){
                var test = function(referencedItem) {return _.contains(item[filter.attr], referencedItem)}
                return ( typeof bool === 'string' ? test(bool) : bool ) || test(referencedItem)
              })
            }),'title') 
                
          }
          // store component
          filter.component =  (
            <Multiselect
              key={timestamp}
              valueField='id' textField='title'
              value={query[filter.by]}
              data={filter.options}
              filter='contains'
              placeholder = {filter.filterlabel}
              onChange = {_.bind(function(values) {
                  this.handleMultiSelectChange(filter.by, _.pluck(values,'id'))
                },this)}                
            />
          )
          filtergroups[filter.filtergroup].filters.push(filter)          
        // if filters.type smart or response
        } else if (filter.filtergroup === 'smart' || filter.filtergroup === 'response') { 
          // options = filtergroups.states
          filter.options = this.state.filtergroups[filter.filtergroup].options
          
          // store component
          filter.component =  ([
            <h6>{filter.filterlabel}</h6>,
            <SelectList
              key={timestamp}
              valueField='value' textField='title'
              value={query[filter.by]}
              data={filter.options}
              multiple={true}
              onChange = {_.bind(function(values) {
                  this.handleMultiSelectChange(filter.by, _.pluck(values,'value'))
                },this)}                
            />]
          )
          
          
          filtergroups[filter.filtergroup].filters.push(filter)  
        // if filters.type date
        } else if (filter.filtergroup === 'date') {
          // calendar dropdown                     
          // store component
          filter.component =  ([            
            <DateTimePicker
              key={timestamp}              
              defaultValue={typeof query[filter.by] !== 'undefined' 
                ? moment(query[filter.by],'MM-YYYY').toDate()
                : null
              }
              placeholder={filter.filterlabel}
              initialView={"year"}
              finalView={"year"}
              format={"MMMM yyyy"}
              time={false}
              parse = {function(str){
                return str !== '' ? new Date(str) : str
              }}
              onChange = {_.bind(function(date) {
                var date_str = date !== '' ? moment(date).format('MM-YYYY') : date
                this.handleDateChange(filter.by, date_str)                  
              },this)}                
            />]
          )    
          filtergroups[filter.filtergroup].filters.push(filter)  

        } 
      },this) // end for each 
      
      
      var GroupComponents = []
      _.each(filtergroups, function(group){
        var width = Math.max(20,100/group.filters.length)


        
        var Component = (
          <div className='hrc-filter-group'>
            <h5>{group.title}</h5>
              {
                _.map(group.filters,function(filter,i){
                  return <span className="hrc-filter-component" 
                    style={{width:width + '%',display:'inline-block'}} 
                    key={i}>
                      {filter.component}
                    </span>
                })
              }
              
            
          </div>
        )
        GroupComponents.push(Component)                
      })
      
      
      
      
      

      return (
        <Grid>
          <h5>Filters: TODO</h5>
          {GroupComponents}          
        </Grid>
      )
    }  
  }, 
  handleMultiSelectChange : function(filter,ids) {
      log('handleRowclick',filter )
      this.getFlux().actions.multiselect(filter,ids)
  },
  handleDateChange : function(filter,date_str) {
      log('handleRowclick',filter )
      this.getFlux().actions.date(filter,date_str)
  }
})

module.exports = FiltersPanel;
