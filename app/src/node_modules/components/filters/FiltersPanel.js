var React       = require('react')
var Fluxxor     = require('fluxxor')
var StoreWatchMixin = Fluxxor.StoreWatchMixin

//components
var Icon        = require('components/icon')
var Load        = require('components/load')

// widgets
Multiselect = require('react-widgets/lib/Multiselect')
SelectList = require('react-widgets/lib/SelectList')
DateTimePicker  = require('react-widgets/lib/DateTimePicker')

// bootstrap
var Grid 				= require('react-bootstrap/lib/Grid')
var Row 				= require('react-bootstrap/lib/Row')
var Col 				= require('react-bootstrap/lib/Col')

//utils
var parseDate   = require('utils/parseDate')

//helpers
var _           = require('lodash')
var moment      = require('moment')
var momentLocalizer = require('react-widgets/lib/localizers/moment')
momentLocalizer(moment);

var log         = require('debug')('src:components:categoryList')

var FiltersPanel = React.createClass({
  mixins: [
    Fluxxor.FluxMixin(React),
    StoreWatchMixin('actions','recommendations','issues','groups','agencies','treatybodies')

  ],
  propTypes : {
    type : React.PropTypes.string,
    query : React.PropTypes.object,
    filterRows: React.PropTypes.array,
    entities : React.PropTypes.array
  },
  getInitialState : function(){
    return {
      showAdvancedFilters: false,
      timestamp : new Date().getTime()
    }
  },
  getStateFromFlux: function () {
    var flux = this.getFlux()
    return {
      loading: {
        actions : flux.store('actions').isLoading()
           ||  flux.store("recommendations").isLoading()
           ||  flux.store("issues").isLoading()
           ||  flux.store("groups").isLoading()
           ||  flux.store("agencies").isLoading(),
        recommendations : flux.store('actions').isLoading()
           ||  flux.store("recommendations").isLoading()
           ||  flux.store("issues").isLoading()
           ||  flux.store("groups").isLoading()
           ||  flux.store("treatybodies").isLoading()
      }

    }
  },
  render: function () {
    log('props',this.props)

    if (this.state.loading[this.props.type]) {
      return (
          <Load/>
      )
    } else {
      
      
      var filterRows = (this.state.showAdvancedFilters ? this.props.filterRows : _.filter(this.props.filterRows,{bydefault:true}))      

      return (
        <div className='hrc-filter-panel-wrapper'>
          <Grid className={'hrc-filter-panel ' + (this.state.showAdvancedFilters ? 'show-advanced-filters' : 'hide-advanced-filters')}>
            {
              _.map(filterRows,function(row,i){
                
                // check if row needs reset 
                var rowReset = row.reset && _.intersection (
                    _(row.groups).pluck('filters').flatten(true).pluck('by').value(), Object.keys(this.props.query)
                  ).length > 0                
              
                var hasTitle = typeof row.title !=='undefined' && row.title !== ''
                
                var rowtitle = 
                  hasTitle ? (
                      <h4>
                        {row.title}
                        {rowReset ? (<a className='hrc-filter-row-reset' href='#' onClick={this.handleRowReset(row)}>Reset</a>) : null}
                      </h4>
                  ) : null

                
                return (
                <div key={i}>
                  {rowtitle}
                  <Row className={hasTitle ? 'row-with-title' : ''} >                                         
                    {
                      _.map(row.groups, function(group, i){                          

                        // calculate filter item width relative to groups span
                        var width = Math.max(20,100/group.filters.length)
                        
                        // check if any filters are set for filtergroup
                        var groupReset = group.reset && _.intersection (_.pluck(group.filters,'by'),Object.keys(this.props.query)).length > 0

                        
                        return (
                          <Col 
                            className={'hrc-filter-group hrc-filter-group-'+ group.group + ' hrc-filter-group-type-'+ group.type + ' col-xxs-' + group.span.xxs} 
                            xs={group.span.xs} sm={group.span.sm} md={group.span.md} key={i}>
                            {
                              group.title !== '' ? (
                                <h5>
                                  {group.title}
                                  {groupReset ? (<a className='hrc-filter-group-reset' href='#' onClick={this.handleGroupReset(group)}>Reset</a>) : null}
                                </h5>
                              ) : null
                            }                            
                            {
                              _.map(group.filters,function(filter,i){
                                return (
                                  <div
                                    className={"hrc-filter-component hrc-filter-component-by-" + filter.by + " hrc-filter-component-type-" + filter.type }
                                    style={{width:width + '%',display:'inline-block'}}
                                    key={i}>
                                      {this.getFilterComponent(group,filter,i)}
                                  </div>
                                )

                              },this)
                            }
                          </Col>
                        )
                      },this)                        

                    }
                  </Row>
                </div>
                )
              },this)
            }
          </Grid>
          <Grid>
            <a href='#' className='hrc-filter-toggle' onClick={this.toggleAdvancedFilters()}>
              <Icon name={!this.state.showAdvancedFilters ?'more':'dismiss-fat'}/>  
              <span className="hidden-xs">{!this.state.showAdvancedFilters ? 'More filter options' : 'Less filter options'}</span>
              <span className="visible-xs">{!this.state.showAdvancedFilters ? 'Show filter options' : 'Hide filter options'}</span>
            </a>
          </Grid>
        </div>
      )
//      }
    }
  },
  getFilterComponent : function(group,filter,i){
    var component

    var flux = this.getFlux()
    var query = this.props.query
    var entities = this.props.entities
    
    switch (group.type) {
      case 'icon' :
        var currentIndex = 0
        // figure out current and next (onclick) index
        _.each(filter.options,function(option,index){
          var currentValue = typeof query[filter.by] !== 'undefined' ? query[filter.by] : ''
          if (option.value === currentValue){
            currentIndex = index
          }
        })        
        var nextIndex = ((currentIndex + 1) < filter.options.length)
          ? (currentIndex + 1)
          : (currentIndex + 1) - filter.options.length
        // figure out current and next (onclick) option
        var currentOption = filter.options[currentIndex]
        var nextOption = filter.options[ nextIndex ]
        
        component = (
          <span className='filter-component-icon'>
            <a href='#' onClick={this.handleIconClick(filter.by, nextOption.value)}>
              <Icon name={currentOption.icon}/>
              <div className={"filter-component-icon-text " + currentOption.value + " " + filter.label.replace(' ', '-' )}>
                {filter.label}
              </div>
            </a>
          </span>
        )

        break

      case 'dateselect' :
        // calendar dropdown
        component =  (
          <span className='filter-component-dateselect'>
            <DateTimePicker
              key={new Date().getTime()}
              value={typeof query[filter.by] !== 'undefined'
                ? moment(query[filter.by],'MM-YYYY').toDate()
                : null
              }
              placeholder={filter.placeholder}
              initialView={"year"}
              finalView={"year"}
              format={"MMMM YYYY"}
              time={false}
              parse = {function(str){
                  return str !== '' ? parseDate(str) : str
              }}
              onChange = {_.bind(function(date) {
                var date_str = date !== '' ? moment(date).format('MM-YYYY') : date
                this.handleDateChange(filter.by, date_str)
              },this)}
            />
          </span>
        )
        break
      case 'multiselect' :
        // get options
        var options = []
        // if filter.type entities
        if (filter.type === 'entities') {
          // get all possible options for entities[filters.attr]
          if (filter.relation === 'to') {
            // get flattened list of all values referencing a related entity (to-relation)
            var referencing = _(entities).pluck(filter.attr).flatten().uniq().value()
            // filter referenced items by referencing list
            options = _.sortBy(flux.stores[filter.attr].filter(function(item){
              return _.contains(referencing,item.id)
            }),'title')
          } else if (filter.relation === 'from') {
            // NOT USED made for recommendations by actions

            // get flattened list of ids that may be referenced by a related entity (from relation)
            var referenced = _(entities).pluck('id').flatten().value()
            // filter referencing items (eg actions) by referenced list (eg recommendations)
            options = _.sortBy(flux.stores[filter.from].filter(function(item){
              return _.reduce(referenced, function(bool, referencedItem){
                var test = function(referencedItem) {return _.contains(item[filter.attr], referencedItem)}
                return ( typeof bool === 'string' ? test(bool) : bool ) || test(referencedItem)
              })
            }),'title')
          }
        }

        var label
        if (i === 0) {
          label = (
            <span className='filter-label'>
              <span className='filter-label-light'>
                {'Filter ' + flux.store(this.props.type).getTitle(entities.length) + ' by '}
              </span>
              <span className='filter-label-bold strong'>
                {filter.label}
              </span>
            </span>
          )
        } else {
          label = (
            <span className='filter-label'>
              <span className='filter-label-light'>by </span>
              <span className='filter-label-bold strong'>
                {filter.label}
              </span>
            </span>
          )
        }

        var values = []
        var referencing = typeof query[filter.by] === 'string' ? [query[filter.by]] : query[filter.by]
        // filter referenced items by referencing list
        values = _.sortBy(flux.stores[filter.attr].filter(function(item){
          return _.contains(referencing,item.id)
        }),'title')
        
        var TagItem = React.createClass({
          render : function() {
            var option = this.props.item;
            var title = option.title.replace('UN Committee','UNC')
            return (
              <span>{ title.length > 26 ? title.substr(0,24)+'\u2026' : title }</span>
            )
          }
        }) 
        
        component = (
          <span className='filter-component-multiselect'>
            {label}
            <Multiselect
              key={new Date().getTime()}
              valueField='id'
              textField='title'
              tagComponent={TagItem}
              value={values}
              data={options}
              filter='contains'
              placeholder = {filter.placeholder}
              onChange = {_.bind(function(values) {
                  this.handleMultiSelectChange(filter.by, _.pluck(values,'id'))
                },this)}
            />
          </span>
        )
        break
    }

    return component


  },
  handleIconClick : function(filter,value) {
    log('handleIconClick',filter )
    var self = this
    return function (e) {
      e.preventDefault()
      self.getFlux().actions.query(filter,value)
    }
  },
  handleMultiSelectChange : function(filter,ids) {
    log('handleMultiSelectChange',filter )
    this.getFlux().actions.multiselect(filter,ids)
  },
  handleDateChange : function(filter,date_str) {
    log('handleDateChange',filter )
    this.getFlux().actions.date(filter,date_str)
  },
  handleGroupReset : function(group) {
    log('handleGroupReset',group.group )
    var self = this
    return function (e) {
      e.preventDefault()
      self.getFlux().actions.deleteFromQuery(_.pluck(group.filters,'by'))
    }
  },
  handleRowReset : function(row) {
    log('handleRowReset',row.rowid )
    var self = this
    return function (e) {
      e.preventDefault()
      self.getFlux().actions.deleteFromQuery(_(row.groups).pluck('filters').flatten(true).pluck('by').value())
    }
  },
  toggleAdvancedFilters: function () {
    var self = this
    return function (e) {
      e.preventDefault()
      self.setState({ showAdvancedFilters: !self.state.showAdvancedFilters })
    }
  }
})

module.exports = FiltersPanel;
