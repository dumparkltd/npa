// flux
var Fluxxor = require('fluxxor')
var actions = require('actions')
var createPdf = require('../../../node_modules/pdfmake/build/pdfmake.js')
var vfs_fonts = require('../../../node_modules/pdfmake/build/vfs_fonts.js')

// helpers
var _       = require('lodash')
var log     = require('debug')('src:node_modules:stores:print-store')
var moment  = require('moment')

// util
var referencing = require('utils/referencing')
var marked = require('utils/parse-markdown')
var parseHTML = require('utils/parse-html')

var actionLayout = require('utils/print/action-layout')
var recommendationsLayout = require('utils/print/recommendations-layout')
var categoryLayout = require('utils/print/category-layout')
var categoryContentLayout = require('utils/print/categorycontent-layout')
var allLayout = require('utils/print/all-layout')

// Print Store handles export to pdf functionality
var PrintStore = Fluxxor.createStore({

  initialize: function (options) {
    this.styles = {
      size34: {fontSize: 34},
      size26: {fontSize: 26},
      size21: {fontSize: 21},
      size18: {fontSize: 18},
      size14: {fontSize: 14},
      size12: {fontSize: 12},
      size10: {fontSize: 10},
      size8_5: {fontSize: 8.5},
      size7_5: {fontSize: 7.5},
      size7: {fontSize: 7},
      size6: {fontSize: 6},
      size5_2: {fontSize: 5.2},
      grey: {color: '#9DA8AB'},
      blue: {color: '#039CE6'},
      green: {color: '#69A31F'},
      white: {color: '#ffffff'},
      bold: {bold: true}
    }
    this.defaultStyles = {
          color: '#0A262D',
          columnGap: 20,
          fontSize: 8.5,
          lineHeight: 1.2
        }

    // route actions
    this.bindActions(
      actions.constants.PRINT, this.print
    )
  },

  print: function (payload) {
    this.waitFor(['actions', 'issues', 'groups', 'agencies', 'pages'],
    function (actionStore, issueStore, groupStore, agencyStore, pageStore) {
      var content,
        category,
        relatedEntities,
        categoryStartPage,
        actionStartPage


      // prepare report data based on report type
      switch (payload.type) {
        // single action report
        case 'action' :
          var action = actionStore.findOne({id: payload.id})
          var recs = referencing(this.flux, {
            entity: action,
            attr: 'recommendations',
            to: 'recommendations'
          })

          // the content
          content = this.getAction(action)
          content.content.push(this.getRecommendations(recs))

          var reportTitle = 'New Zealand’s National Plan of Action | Action report | Action: ' + action.title

          break

        // issue category report
        case 'issue' :
          category = issueStore.findOne({id: payload.id})
          content = this.getCategory(payload, category, 'issues')
          reportTitle = 'New Zealand’s National Plan of Action | Category report | Issue: ' + category.title
          break
        // group category report
        case 'group' :
          category = groupStore.findOne({id: payload.id})
          content = this.getCategory(payload, category, 'groups')
          reportTitle = 'New Zealand’s National Plan of Action | Category report | Group: ' + category.title
          break
        // agency category report
        case 'agency' :
          category = agencyStore.findOne({id: payload.id})
          content = this.getCategory(payload, category, 'agencies')
          reportTitle = 'New Zealand’s National Plan of Action | Category report | Agency: ' + category.title
          break
        // full report
        case 'all' :
          relatedEntities = actionStore.entities()
          var allAgencies = agencyStore.entities()
          var allGroups = groupStore.entities()
          var allIssues = issueStore.entities()

          content = this.getAll(payload, relatedEntities, allAgencies, allGroups, allIssues)
          reportTitle = 'New Zealand’s National Plan of Action | Full report'
          break
        // custom filtered report
        case 'filtered' :
          break
      }

      var lastFooterMode

      // the document definition object
      var docDefinition = {
        content: content.content,
        styles: this.styles,
        defaultStyle: this.defaultStyle,
        background: function (currentPage) {
          // title page if not single action report
          if (currentPage == 1 && payload.type !== 'action'){
            return {canvas: [
              {
                type: 'polyline',
                lineWidth: 2,
                color: '#4c99da',
                lineColor: '',
                points: [{x: 40, y: 40}, {x: 40, y: 800}, {x: 560, y: 800}, {x: 560, y: 90}, {x: 510, y: 40}, {x: 40, y: 40}]
              }
            ]}
          }
        },
        images: {
        },
        header: function (currentPage) {
          if (currentPage !== 1) {
            return {
              image: 'icon_logo_grey',
              width: 25,
              alignment: 'right',
              margin: [0, 30, 30, 0]
            }
          }
        },
        footer: function (currentPage, pageCount, footerMode) {
          switch (footerMode) {
            case 'action':
              if (lastFooterMode !== footerMode) {
                actionStartPage = currentPage - 1
              }
              lastFooterMode = 'action'
              return {
                stack: [
                {canvas: [{ type: 'line', x1: 0, y1: 5, x2: 520, y2: 5, lineColor: '#9aa6a6', lineWidth: 0.5 }]},
                {columns: [
                  {text: reportTitle,
                  alignment: 'left',
                  style: ['size7', 'grey']},
                  {text: 'B|' + (currentPage - actionStartPage).toString(),
                  alignment: 'right',
                  style: ['size14', 'grey']}
                ], margin: [0, 6, 0, 0]}],
                margin: [40, 0]
              }
            case 'appendix':
              if (lastFooterMode !== footerMode) {
                var appendixStartPage = currentPage - 1
              }
              lastFooterMode = 'appendix'
              return {
                stack: [
                {canvas: [{ type: 'line', x1: 0, y1: 5, x2: 520, y2: 5, lineColor: '#9aa6a6', lineWidth: 0.5 }]},
                {columns: [
                  {text: reportTitle,
                  alignment: 'left',
                  style: ['size7', 'grey']},
                  {text: 'C|' + (currentPage - appendixStartPage).toString(),
                  alignment: 'right',
                  style: ['size14', 'grey']}
                ], margin: [0, 6, 0, 0]}],
                margin: [40, 0]
              }
            case 'category':
              if (lastFooterMode !== footerMode) {
                categoryStartPage = currentPage - 1
              }
              lastFooterMode = 'category'
              return {
                stack: [
                {canvas: [{ type: 'line', x1: 0, y1: 5, x2: 520, y2: 5, lineColor: '#9aa6a6', lineWidth: 0.5 }]},
                {columns: [
                  {text: reportTitle,
                  alignment: 'left',
                  style: ['size7', 'grey']},
                  {text: 'A|' + (currentPage - categoryStartPage).toString(),
                  alignment: 'right',
                  style: ['size14', 'grey']}
                ], margin: [0, 6, 0, 0]}],
                margin: [40, 0]
              }
          }
        }
      }

      // wait for images to be loaded before printing pdf
      var dataUrlCount = 0
      var onSuccess = function (e) {
        dataUrlCount++
        if (dataUrlCount === _.size(loadImages)) {

          // finally print pdf
          pdfMake.createPdf(docDefinition).download()
        }
      }
      var onError = function (e) {
        console.log(e.message)
      }

      var loadImages = {
        icon_arrow_dark: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_arrow-dark.png', onSuccess, onError, 'icon_arrow_dark', docDefinition),
        icon_assignable_yes: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_assignable-yes-large.png', onSuccess, onError, 'icon_assignable_yes', docDefinition),
        icon_assignable_no: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_assignable-no-large.png', onSuccess, onError, 'icon_assignable_no', docDefinition),
        icon_logo_grey: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_logo-grey.png', onSuccess, onError, 'icon_logo_grey', docDefinition),
        icon_logo_white: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_logo-white.png', onSuccess, onError, 'icon_logo_white', docDefinition),
        icon_measurable_yes: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_measurable-yes-large.png', onSuccess, onError, 'icon_measurable_yes', docDefinition),
        icon_measurable_no: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_measurable-no-large.png', onSuccess, onError, 'icon_measurable_no', docDefinition),
        icon_rec_no: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_rec-no-large.png', onSuccess, onError, 'icon_rec_no', docDefinition),
        icon_rec_yes: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_rec-yes-large.png', onSuccess, onError, 'icon_rec_yes', docDefinition),
        icon_result_yes: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_result-yes-large.png', onSuccess, onError, 'icon_result_yes', docDefinition),
        icon_result_no: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_result-no-large.png', onSuccess, onError, 'icon_result_no', docDefinition),
        icon_smart_key_yes: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_smart-key-yes.png', onSuccess, onError, 'icon_smart_key_yes', docDefinition),
        icon_smart_key_no: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_smart-key-no.png', onSuccess, onError, 'icon_smart_key_no', docDefinition),
        icon_specific_yes: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_specific-yes-large.png', onSuccess, onError, 'icon_specific_yes', docDefinition),
        icon_specific_no: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_specific-no-large.png', onSuccess, onError, 'icon_specific_no', docDefinition),
        icon_time_yes: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_time-yes-large.png', onSuccess, onError, 'icon_time_yes', docDefinition),
        icon_time_no: this.getImageDataURL('img/pdf-icons/NPA-pdf-icons_time-no-large.png', onSuccess, onError, 'icon_time_no', docDefinition)
      }
    })
  },

  getAction: function (action) {
    var issues = referencing(this.flux, {
      entity: action,
      attr: 'issues',
      to: 'issues'
    })

    var groups = referencing(this.flux, {
      entity: action,
      attr: 'groups',
      to: 'groups'
    })

    var agencies = referencing(this.flux, {
      entity: action,
      attr: 'agencies',
      to: 'agencies'
    })

    var titles = {
      issuesTitle: this.flux.store('issues').getTitle(issues.length),
      groupsTitle: this.flux.store('groups').getTitle(groups.length),
      agenciesTitle: this.flux.store('agencies').getTitle(agencies.length)
    }

    var actionContent = actionLayout(action, issues, groups, agencies, titles)

    return actionContent
  },

  makeCategoryList: function (categories) {
    return _.map(categories, function (cat) { return cat.title }).join(', ')
  },

  getRecommendations: function (recs) {
    var content = recommendationsLayout(recs)

    var recsIndex = _.map(recs, function (value, key) {
      var tableOfContents = {
        stack: [
          {columns: [
            {width: '6%', text: value.id, style: ['size10', 'bold'], alignment: 'right', margin: [0, 8, 7, 0]},
            {width: '79%', text: value.title, style: ['size7_5'], margin: [0, 4, 0, 0]},
            //  Need to pull in master branch to get this going
          //  {image: this.getRelatedActionsLength(value) > 0 ? 'icon_rec_yes' : 'icon_rec_no', width: 20},
            {width: '7%', stack: [{image: value.response === 'accepted' ? 'icon_rec_yes' : 'icon_rec_no', width: 20}], margin: [0, 4, 0, 0]},
            {width: '7%', stack: [{image: value.response === 'accepted' ? 'icon_rec_yes' : 'icon_rec_no', width: 20}], margin: [0, 4, 0, 0]}
          ], columnGap: 1},
          {canvas: [{ type: 'line', x1: 0, y1: 5, x2: 520, y2: 5, lineColor: '#9aa6a6', lineWidth: 0.5 }]}
        ],
        footerMode: 'appendix'
      }
      return tableOfContents
    }, this)

    return [content, recsIndex]
  },

  getRelatedActionsLength: function (rec) {
    var actions = referencing(this.flux, {
      entity: rec,
      attr: 'recommendations',
      to: 'actions'
    })
    return _.size(actions)
  },

  getCategory: function (payload, category, type) {
    var relatedEntities = referencing(this.flux, {
      entity: category,
      attr: type,
      from: 'actions'
    })

    var relatedEntitiesAction = _.map(relatedEntities, function (value, key) {
      return {stack: this.getAction(value).content}
    }, this)

    var recs = referencing(this.flux, {
      entity: category,
      attr: type,
      from: 'recommendations'
    })

    var categoryContent = categoryLayout(payload, category, type, relatedEntities, relatedEntitiesAction, recs)

    categoryContent.content.push(this.getRecommendations(recs))

    return categoryContent
  },

  getAll: function (payload, relatedEntities, allAgencies, allGroups, allIssues) {
    var relatedGroupEntities = _.map(allGroups, function (value, key) {
      var relatedGroupActions = referencing(this.flux, {
        entity: value,
        attr: 'groups',
        from: 'actions'
      })
      var category = categoryContentLayout(value, 'group', relatedGroupActions, relatedEntities)
      return category.category
    }, this)

    var relatedIssueEntities = _.map(allIssues, function (value, key) {
      var relatedIssueActions = referencing(this.flux, {
        entity: value,
        attr: 'issues',
        from: 'actions'
      })
      var category = categoryContentLayout(value, 'issue', relatedIssueActions, relatedEntities)
      return category.category
    }, this)

    var relatedAgencyEntities = _.map(allAgencies, function (value, key) {
      var relatedAgencyActions = referencing(this.flux, {
        entity: value,
        attr: 'agencies',
        from: 'actions'
      })
      var category = categoryContentLayout(value, 'agency', relatedAgencyActions, relatedEntities)
      return category.category
    }, this)

    var relatedEntitiesAction = _.map(relatedEntities, function (value, key) {
      return {stack: this.getAction(value).content}
    }, this)

    var allContent = allLayout(relatedEntitiesAction, relatedGroupEntities, relatedIssueEntities, relatedAgencyEntities)

    return allContent
  },

  getImageDataURL: function (url, success, error, name, docDefinition) {
    var data, canvas, ctx
    var img = new Image()
    img.onload = function () {
      // Create the canvas element.
      canvas = document.createElement('canvas')
      canvas.width = img.width
      canvas.height = img.height
      // Get '2d' context and draw the image.
      ctx = canvas.getContext('2d')
      ctx.drawImage(img, 0, 0)
      // Get canvas data URL
      try {
        data = canvas.toDataURL()
        docDefinition.images[name] = data
        success({image: img, data: data})
      } catch (e) {
        error(e)
      }
    }
    // Load image URL.
    try {
      img.src = url
    } catch (e) {
      error(e)
    }
  }
})

module.exports = PrintStore
