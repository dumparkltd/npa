// flux
var Fluxxor = require('fluxxor')
var actions = require('actions')
var ga        = require("react-ga")

// helpers
var _       = require('lodash')
var log     = require('debug')('src:node_modules:stores:print-store')

//utils
var marked = require('utils/parse-markdown')
var checkSMART = require('utils/check-smart')
var referencing = require('utils/referencing')
var formatDate = require('utils/format-date')
var parseDate = require('utils/parse-date')
var moment = require('moment')

//print
var printPdf = require('printPdf/print-pdf')



// Print Store handles export to pdf functionality
var PrintStore = Fluxxor.createStore({

  initialize: function (options) {        
    
    this.status = {code:'',message:''}
    
    // route actions
    this.bindActions(
      actions.constants.PRINT, this.print
    )
  },
  getStatus: function(){
    return this.status
  },
  setStatus : function (args) {
    log(args.status.message)
    this.status = args.status
    if (this.status.level === 'info' || this.status.level === 'error') {
      this.emit('change')
    }
  },
  print: function (payload) {    
    this.waitFor(
      ['actions', 'issues', 'groups', 'agencies', 'recommendations'],
      function (actionStore, issueStore, groupStore, agencyStore, recommendationStore) {           
        var statusMessage = 'Generating\u2026'
             
        var report = {}
        report.type = payload.type
        report.id = payload.id        
        report.data = {}
                 
        // gather data
        // prepare report data based on report type
        switch (payload.type) {
         // single action report
          case 'action' :  
//            statusMessage += ' Action Report\u2026'
            report.filename = 'NPA-Action-' + payload.id + '.pdf'
            // prepare data                        
            report.data = {              
              actionData           : this.prepareActionData( payload.id),              
              recommendationsTable : this.prepareRecommendationsTable( payload.type, payload.id)
            }
            report.sections = [
              {short:'A', title : 'Section A', content : ['1 Government Action']},
              {short:'B', title : 'Section B (Appendix)', content : 
                [ 
                  report.data.recommendationsTable.count + ' addressed UPR Recommendations'
                ]
              }
            ]
            report.titleData = {
              reportType : 'Action\nReport',
              supTitle : 'Government Action '  + report.id ,
              reportTitle : report.data.actionData.title,              
              date :moment().format('DD/MM/YYYY'),
              ISBN : '978-0-478-3565',
              url : window.location.href
            }
            report.footer = {
              title : 'Action Report: Government Action ' + report.id
            }
            break

          // issue category report
          case 'issue' : 
          case 'group' : 
          case 'agency' : 
//            statusMessage += ' Category Report\u2026'
            report.filename = 'NPA-Category-' + payload.id + '.pdf'
            // prepare data
            report.data = {            
              categoryData : this.prepareCategoryData( payload.type, payload.type, payload.id),            
              actionsDataList : this.prepareActionsDataList( payload.type, payload.id)            
            }
            if (report.data.actionsDataList.length > 0) {
              report.sections = [
                {title : 'Section A', short: 'A', content : ['1 ' + report.data.categoryData.supTitle]},
                {title : 'Section B', short: 'B', content : 
                  [ 
                    report.data.actionsDataList.length + ' Government Actions'
                  ]
                }
              ]
            } else {
              report.sections = [
                {title : 'Section A', short: 'A', content : ['1 ' + report.data.categoryData.supTitle]}
              ]
            }
            report.titleData = {
              reportType : 'Category\nReport',
              supTitle : report.data.categoryData.supTitle,
              reportTitle : report.data.categoryData.title,              
              date :moment().format('DD/MM/YYYY'),
              ISBN : '978-0-478-3565',
              url : window.location.href
            }
            report.footer = {
              title : 'Category Report: ' + report.data.categoryData.title 
            }
            break

          // full report
          case 'all' :
//            statusMessage += ' Full Report\u2026'
            report.filename = 'NPA-Full-Report.pdf'
            // prepare data
            report.data = {            
              categoriesDataList : {
                issue : this.prepareCategoriesDataList('issue'),
                group : this.prepareCategoriesDataList('group'),
                agency : this.prepareCategoriesDataList('agency')
              },
              actionsDataList : this.prepareActionsDataList( payload.type),             
              recommendationsTable : this.prepareRecommendationsTable( payload.type)
            }
            report.sections = [
              {short:'A', title : 'Section A', content : 
                [
                  report.data.categoriesDataList.issue.length + ' Issues',
                  report.data.categoriesDataList.group.length + ' Population Groups',
                  report.data.categoriesDataList.agency.length + ' Government Agencies'
                ]
              },
              {short:'B', title : 'Section B', content : 
                [ 
                  report.data.actionsDataList.length + ' Government Actions'
                ]
              },
              {short:'C', title : 'Section C (Appendix)', content : 
                [ 
                  report.data.recommendationsTable.count + ' UPR Recommendations'
                ]
              }

            ]
            report.titleData = {
              reportType : 'Full\nReport',
              supTitle : '',
              reportTitle : ['National Plan of Action 2015 \u2013 2019'],              
              date :moment().format('DD/MM/YYYY'),
              ISBN : '978-0-478-3565',
              url : window.location.href
            }
            report.footer = {
              title : 'Full Report 2015 \u2013 2019' 
            }

            break
          // full report
          case 'custom' :
//            statusMessage += ' Custom Report\u2026'
            report.filename = 'NPA-Custom-Report.pdf'
            // prepare data
            report.data = {    
              actionsTable : this.prepareActionsTable('custom','custom','custom',payload.actions),
              actionsDataList : _.map(payload.actions,function(action){
                          return this.prepareActionData(action.id)
                        },this)
            }            
            report.sections = [
              {short:'A', title : 'Section A', content : 
                [
                  'Government Actions overview'
                ]
              },
              {short:'B', title : 'Section B', content : 
                [
                  report.data.actionsDataList.length + ' Government Actions'
                ]
              }
            ]
            report.titleData = {
              reportType : 'Custom\nReport',
              supTitle : '',
              reportTitle : ['Selected Government Actions'],              
              date :moment().format('DD/MM/YYYY'),
              ISBN : '978-0-478-3565',
              url : window.location.href.length < 130 
                ? window.location.href 
                : window.location.href.slice(0, window.location.href.indexOf("?")),
              filterData : this.prepareFilterData(payload.query,payload.filters)
            }
            report.footer = {
              title : 'Custom Report' 
            }

            break
        }  
        var reportId = Math.random().toString(36).slice(-8).toUpperCase();
        this.setStatus({
          id:reportId,
          status:{
            code: 'ready_data',
            message:'Report data ready',
            level:'debug'
          }
        })
        
        this.setStatus({
          id:reportId,
          status:{
            code: 'print_report',
            message:statusMessage,
            level:'info'
          }
        })        
        // call print routine with callback (not using action here to 
        // keep printPdf React independent module
        printPdf(report, reportId, this.setStatus)                
        ga.event({
          category:'print',      
          action:report.type+'/'+report.id + (payload.query ? '/'+JSON.stringify(payload.query).replace(/"|{|}/g,'') : '')
        })           
      } 
    )
  },
  prepareFilterData : function (query,filterDefinitions)   {
    
    var filterData = []
    
    _.each(filterDefinitions,function(filterDefinition){
      
      //list filters individually
      if (filterDefinition.groups.length === 1) {
        _.each(filterDefinition.groups[0].filters,function(filterItem){
          if (_.contains(_.keys(query),filterItem.by)){
            filterData.push({
              title : filterItem.label,
              rows : _.pluck(this.flux.stores[filterItem.attr].filter(
                        function(category){
                          if (_.isArray(query[filterItem.by])) {
                            return _.contains( query[filterItem.by], category.id)
                          } else {
                            return query[filterItem.by] === category.id
                          }                
                        }),
                        'title'
                      )
            })
          }
        },this)        
      //group filters
      } else {
        
        var groups = _.filter(filterDefinition.groups,
          function(group){
            return _.intersection(_.keys(query),_.pluck(group.filters,'by')).length > 0
          }
        )
        
        if (groups.length > 0 ) {
          
          filterData.push({
            title: filterDefinition.title,
            rows: _.map(groups,function(group){
                    if (group.group === 'date') {                      
                      return group.title + ': ' + formatDate(parseDate(query[group.filters[0].by])) 
                    } else {
                      var filters = _.filter(group.filters,function(filter){
                        return _.contains(_.keys(query),filter.by) && query[filter.by] === filter.value
                      })
                      return group.title + ': ' + filters[0].label
                    }
                  })
          })
        }
        
        
      }
      
      
    },this)
    return filterData
  },
  // content for one single action
  prepareActionData: function (id) {
        
    var action = this.flux.stores.actions.findOne({id: id})
    
    var issues = 
            referencing(this.flux, { entity: action, attr: 'issues', to: 'issues' })
    var groups = 
            referencing(this.flux, { entity: action, attr: 'groups', to: 'groups' })
    var agencies = 
            referencing(this.flux, { entity: action, attr: 'agencies', to: 'agencies' })
    var recommendations = 
            referencing(this.flux, { entity: action, attr: 'recommendations', to: 'recommendations' })
    
    return {
      id : id,
      title : action.title,
      content : [
        { title: 'Description', type :'html', content : marked(action.description) },
        { title: 'Desired Outcome', type :'html', content : marked(action.desiredoutcome) },
        { title: 'Measures',type :'html', content : marked(action.measures) },
        _.isEmpty(action.targetdate) 
          ? { title:'Target Date', type : 'text', content : action.targetdatecomment }
          : { title:'Target Date', type : 'targetDate', content : [formatDate(action.targetdate), action.targetdatecomment]}          
      ],
      smart : {
        isspecific : checkSMART(action.isspecific),
        ismeasurable : checkSMART(action.ismeasurable),
        isassignable : checkSMART(action.isassignable),
        isresultoriented : checkSMART(action.isresultoriented),
        istimebound : checkSMART(action.istimebound)
      },
      categories : {
        issues : _.pluck(issues,'title'),
        groups : _.pluck(groups,'title'),
        agencies : _.pluck(agencies,'title'),
      },
      recommendations : _.pluck(recommendations,'id')
      
    }

  },
  
  // content for a single category
  prepareCategoryData : function(reportType, categoryType, id){
    var category
    var supTitle
    var contentTitle
    var contentMain
    var contentAside
    var contentAsideTitle
    var recommendationsList
    var recommendationsTable
    var recommendationsAttribute

    switch (categoryType) {
      case 'issue' : 
        category = this.flux.stores.issues.findOne({ id: id })
        supTitle = this.flux.stores.issues.getTitle(1),
        contentTitle = 'Current Context'
        contentMain = marked(category.currentcontext)
        contentAsideTitle = 'Other Issues raised by Civil Society'
        contentAside = marked(category.otherissuesraised)
        if (reportType === 'all') {
          var recommendations = referencing(this.flux, {
            entity : category, // the issue/group
            attr : 'issues',
            from : 'recommendations'
          })
          recommendationsList = _.pluck(recommendations,'id')
        } else if (reportType === 'issue') {
          recommendationsTable = this.prepareRecommendationsTable(categoryType,id)
        }
        break
      case 'group' : 
        category = this.flux.stores.groups.findOne({ id: id })
        supTitle = this.flux.stores.groups.getTitle(1)
        contentTitle = 'Current Context'
        contentMain = marked(category.commentary)
        contentAsideTitle = 'About this Group'
        contentAside = marked(category.description)
        if (reportType === 'all') {
          var recommendations = referencing(this.flux, {
            entity : category, // the issue/group
            attr : 'groups',
            from : 'recommendations'
          })
          recommendationsList = _.pluck(recommendations,'id')
          // included as list on category page
        } else if (reportType === 'group') {
          recommendationsTable = this.prepareRecommendationsTable(categoryType,id)
          // included as table on its own page
        }
        break
      case 'agency' : 
        category = this.flux.stores.agencies.findOne({ id: id })
        supTitle = this.flux.stores.agencies.getTitle(1)
        contentTitle = 'Description'
        contentMain = marked(category.description)
        contentAsideTitle = 'Website'
        contentAside = category.link
        break
    }  
            
    return {
      supTitle : supTitle,
      title : category.title,
      contentTitle : contentTitle,
      content : contentMain,
      aside :  contentAside,
      asideTitle :  contentAsideTitle,
      recommendationsList : recommendationsList,
      recommendationsTable : recommendationsTable,
      actionsTable : this.prepareActionsTable(reportType, categoryType, id)
    }
  },
  
  // an action index table (used in category content)
  prepareActionsTable: function(reportType,categoryType,id,filteredActions){
    
    var actions 
    var supTitle    
    
    switch (categoryType) {
      case 'issue' : 
        actions = referencing(this.flux, {
          entity : id, // the issue
          attr : 'issues',
          from : 'actions'
        })
        supTitle = this.flux.stores.issues.getTitle() + ': ' + this.flux.stores.issues.findOne({id:id}).title
        break
      case 'group' : 
        actions = referencing(this.flux, {
          entity : id, // the group
          attr : 'groups',
          from : 'actions'
        })
        supTitle = this.flux.stores.groups.getTitle() + ': ' + this.flux.stores.groups.findOne({id:id}).title
        break
      case 'agency' : 
        actions = referencing(this.flux, {
          entity : id, // the group
          attr : 'agencies',
          from : 'actions'
        })
        supTitle = this.flux.stores.agencies.getTitle() + ': ' + this.flux.stores.agencies.findOne({id:id}).title
        break
      case 'custom':
        actions = filteredActions
        supTitle = 'Selected Government Actions'
    }            
    
    var allActions = reportType === 'all' ?  this.flux.stores.actions.entities() : actions
    
    var pageNo = 0
    var indexOfActions = _.map(allActions, function (action) {
      var pageNoToUse = pageNo + 1
      pageNo += (this.isNumeric(action.printnoofpages) ? parseInt(action.printnoofpages) : 1)
      return {id: action.id, pageNo: pageNoToUse}
    },this) 
    
    return {
      count : actions.length,
      supTitle : supTitle,
      title :  actions.length + ' ' + this.flux.stores.actions.getTitle(actions.length),
      list : _.map(actions,function(action){         
        return {
          id : action.id,
          title : action.title,
          isspecific : checkSMART(action.isspecific),
          ismeasurable : checkSMART(action.ismeasurable),
          isassignable : checkSMART(action.isassignable),
          isresultoriented : checkSMART(action.isresultoriented),
          istimebound : checkSMART(action.istimebound),
          pageNo : _.findWhere(indexOfActions, {id: action.id}).pageNo 
        }
      })
    }
   
    
  },
  
   // a recommendation table (used in category content)
  prepareRecommendationsTable: function(type,id){
    
    var recommendations 
    var supTitle    
    var titleAttribute 
    
    switch (type) {
      case 'action' :      
        recommendations = referencing(this.flux, {
          entity: this.flux.stores.actions.findOne({id:id}), // the action
          attr: 'recommendations',
          to: 'recommendations'
        })
        supTitle = 'Government Action ' + id
        titleAttribute = ' addressed '
        break
      case 'issue' : 
        recommendations = referencing(this.flux, {
          entity : id, // the issue
          attr : 'issues',
          from : 'recommendations'
        })
        supTitle = this.flux.stores.issues.getTitle() + ': ' + this.flux.stores.issues.findOne({id:id}).title
        titleAttribute = ' related '                
        break
      case 'group' : 
        recommendations = referencing(this.flux, {
          entity : id, // the group
          attr : 'groups',
          from : 'recommendations'
        })
        supTitle = this.flux.stores.groups.getTitle() + ': ' + this.flux.stores.groups.findOne({id:id}).title
        titleAttribute = ' related '
        break
      case 'all' : 
        recommendations = this.flux.stores.recommendations.entities()
        supTitle = ''
        titleAttribute = ' '
        break
    }            
    
    return {
      count : recommendations.length,
      supTitle : supTitle,
      title :  recommendations.length 
              + titleAttribute 
              + this.flux.stores.recommendations.getTitle(recommendations.length),
      list : _.map(recommendations,function(rec){
         var actions = referencing(this.flux, {
          entity : rec.id, // the recommendation id
          attr : 'recommendations',
          from : 'actions'
         })
        return {
          id : rec.id,
          title : rec.title,
          addressed : actions.length > 0,
          accepted : rec.response === 'Accepted'
        }
      },this)
    }
  
  },
  
  // alist of categories (used in all actions report)
  prepareCategoriesDataList : function(categoryType){
    var categories
    switch (categoryType) {
      case 'issue' : 
        categories = this.flux.stores.issues.entities()
        break
      case 'group' : 
        categories = this.flux.stores.groups.entities()
        break
      case 'agency' : 
        categories = this.flux.stores.agencies.entities()
        break
      
    }            
    return _.map(categories,function(cat){
      return this.prepareCategoryData('all',categoryType,cat.id)
    },this)
  },
    
  // content for all report actions (category and all actions reports)
  prepareActionsDataList : function(reportType, id){
    var actions
    switch (reportType) {
      case 'issue' : 
        actions = referencing(this.flux, {
          entity : id, // the issue
          attr : 'issues',
          from : 'actions'
        })
        break
      case 'group' : 
        actions = referencing(this.flux, {
          entity : id, // the group
          attr : 'groups',
          from : 'actions'
        })
        break
      case 'agency' : 
        actions = referencing(this.flux, {
          entity : id, // the group
          attr : 'agencies',
          from : 'actions'
        })
        break
      case 'all' : 
        actions = this.flux.stores.actions.entities()
        break
    }            
    return _.map(actions,function(action){
      return this.prepareActionData(action.id)
    },this)
  },
  
  
  
  
  
  
  
  isNumeric: function( obj ) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    return obj - parseFloat( obj ) >= 0;
  }  
  
})

module.exports = PrintStore
