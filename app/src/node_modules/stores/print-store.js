// flux
var Fluxxor = require('fluxxor')
var actions = require('actions')
var $script  = require('scriptjs')

// helpers
var _       = require('lodash')
var log     = require('debug')('src:node_modules:stores:print-store')
var moment  = require('moment')

//utils
var marked = require('utils/parse-markdown')
var checkSMART = require('utils/checkSMART')
var referencing = require('utils/referencing')

//print
var printPdf = require('printPdf/printPdf')



// Print Store handles export to pdf functionality
var PrintStore = Fluxxor.createStore({

  initialize: function (options) {
    

    // route actions
    this.bindActions(
      actions.constants.PRINT, this.print
    )
  },

  print: function (payload) {    
    this.waitFor(
      ['actions', 'issues', 'groups', 'agencies', 'recommendations'],
      function (actionStore, issueStore, groupStore, agencyStore, recommendationStore) {           
        
        var report = {}
        report.type = payload.type
        report.id = payload.id        
        report.data = {}
        // gather data
        // prepare report data based on report type
        switch (payload.type) {
         // single action report
          case 'action' :           
            // prepare data
            report.data = {
              actionContent        : this.prepareActionContent( payload.id),              
              recommendationsTable : this.prepareRecommendationsTable( payload.type, payload.id)
            }

            break

          // issue category report
          case 'issue' : case 'group' : case 'agency' : 
            // prepare data
            report.data = {            
              categoryContent : this.prepareCategoryContent( payload.type, payload.type, payload.id),            
              actionsContentList : this.prepareActionsContentList( payload.type, payload.id)            
            }

            break

          // full report
          case 'all' :

            // prepare data
            report.data = {            
              categoriesContentList : {
                issues : this.prepareCategoriesContentList('issue'),
                groups : this.prepareCategoriesContentList('group'),
                agencies : this.prepareCategoriesContentList('agency')
              },
              actionsContentList : this.prepareActionsContentList( payload.type),             
              recommendationsTable : this.prepareRecommendationsTable( payload.type)
            }

            break
        }  


        // load print scripts
        $script(['js/pdfmake.min.js', 'js/vfs_fonts.js'], function() {        
          printPdf(report)                
        }) 
        
      } // end callback function (on store load)
    )
  },
  
  
  // content for one single action
  prepareActionContent: function (id) {
        
    var action = this.flux.stores.actions.findOne({id: id})
    
    var issues = 
            referencing(this.flux, { entity: action, attr: 'issues', to: 'issues' })
    var groups = 
            referencing(this.flux, { entity: action, attr: 'groups', to: 'groups' })
    var agencies = 
            referencing(this.flux, { entity: action, attr: 'agencies', to: 'agencies' })
    var recommendations = 
            referencing(this.flux, { entity: action, attr: 'recommendations', to: 'recommendations' })
    
    return {
      id : id,
      title : action.title,
      content : [
        { type :'html', html : marked(action.description) },
        { type :'html', html : marked(action.desiredoutcome) },
        { type :'html', html : marked(action.measures) },
        _.isEmpty(action.targetdate) 
          ? { type : 'text', text : action.targetdatecomment }
          : { type : 'list', list : [action.targetdate, action.targetdatecomment]}          
      ],
      smart : [
        checkSMART(action.isspecific),
        checkSMART(action.ismeasurable),
        checkSMART(action.isassignable),
        checkSMART(action.isresultoriented),
        checkSMART(action.istimebound)
      ],
      categories : {
        issues : _.pluck(issues,'title'),
        groups : _.pluck(groups,'title'),
        agencies : _.pluck(agencies,'title'),
      },
      recommendations : _.pluck(recommendations,'id')
      
    }

  },
  
  // content for a single category
  prepareCategoryContent : function(reportType, categoryType, id){
    var category
    var supTitle
    var contentMain
    var contentAside
    var recommendationsList
    var recommendationsTable
    

    switch (categoryType) {
      case 'issue' : 
        category = this.flux.stores.issues.findOne({ id: id })
        supTitle = this.flux.stores.issues.getTitle(1),
        contentMain = category.currentcontext
        contentAside = category.otherissuesraised       
        break
      case 'group' : 
        category = this.flux.stores.groups.findOne({ id: id })
        supTitle = this.flux.stores.groups.getTitle(1)
        contentMain = category.commentary
        contentAside = category.description
        break
      case 'agency' : 
        category = this.flux.stores.agencies.findOne({ id: id })
        supTitle = this.flux.stores.agencies.getTitle(1)
        contentMain = category.description
        contentAside = category.link
        break
    }

    switch (reportType) {
      case 'all' :
        recommendationsList = _.pluck(this.flux.stores.recommendations.entities(),'id')
        // included as list on issue page
        break
      case 'issue' : case 'group' :
        recommendationsTable = this.prepareRecommendationsTable(categoryType,id)
        // included as table on its own page
        break      
    }    
            
    return {
      supTitle : supTitle,
      title : category.title,
      content : { type :'html', html : contentMain },
      aside : { type :'html', html : contentAside },
      recommendationsList : recommendationsList,
      recommendationsTable : recommendationsTable,
      actionsTable : this.prepareActionsTable(reportType, categoryType, id)
    }
  },
  
  // an action index table (used in category content)
  prepareActionsTable: function(reportType,categoryType,id){
    
    var actions 
    var supTitle    
    
    switch (categoryType) {
      case 'issue' : 
        actions = referencing(this.flux, {
          entity : id, // the issue
          attr : 'issues',
          from : 'actions'
        })
        supTitle = this.flux.stores.issues.getTitle() + ': ' + this.flux.stores.issues.findOne({id:id}).title
        break
      case 'group' : 
        actions = referencing(this.flux, {
          entity : id, // the group
          attr : 'groups',
          from : 'actions'
        })
        supTitle = this.flux.stores.groups.getTitle() + ': ' + this.flux.stores.groups.findOne({id:id}).title
        break
      case 'agency' : 
        actions = referencing(this.flux, {
          entity : id, // the group
          attr : 'agencies',
          from : 'actions'
        })
        supTitle = this.flux.stores.agencies.getTitle() + ': ' + this.flux.stores.agencies.findOne({id:id}).title
        break
    }            
    
    var allActions = reportType === 'all' ?  this.flux.stores.actions.entities() : actions
    
    var pageNo = 0
    var indexOfActions = _.map(allActions, function (action) {
      var pageNumToUse = pageNo + 1
      pageNo += (this.isNumeric(action.printnoofpages) ? action.printnoofpages : 1)
      return {id: action.id, pageNum: pageNumToUse}
    }) 
    
    return {
      count : actions.length,
      supTitle : supTitle,
      title :  actions.length + ' ' + this.flux.stores.recommendations.getTitle(actions.length),
      list : _.map(actions,function(action){         
        return {
          id : action.id,
          title : action.title,
          isspecific : checkSMART(action.isspecific),
          ismeasurable : checkSMART(action.ismeasurable),
          isassignable : checkSMART(action.isassignable),
          isresultoriented : checkSMART(action.isresultoriented),
          istimebound : checkSMART(action.istimebound),
          pageNo : _.findWhere(indexOfActions, {id: action.id}) 
        }
      })
    }
   
    
  },
  
   // a recommendation table (used in category content)
  prepareRecommendationsTable: function(type,id){
    
    var recommendations 
    var supTitle    
    var titleAttribute 
    
    switch (type) {
      case 'action' :      
        recommendations = referencing(this.flux, {
          entity: this.flux.stores.actions.findOne({id:id}), // the action
          attr: 'recommendations',
          to: 'recommendations'
        })
        supTitle = 'Action ' + id
        titleAttribute = ' addressed '
        break
      case 'issue' : 
        recommendations = referencing(this.flux, {
          entity : id, // the issue
          attr : 'issues',
          from : 'recommendations'
        })
        supTitle = this.flux.stores.issues.getTitle() + ': ' + this.flux.stores.issues.findOne({id:id}).title
        titleAttribute = ' related '                
        break
      case 'group' : 
        recommendations = referencing(this.flux, {
          entity : id, // the group
          attr : 'groups',
          from : 'recommendations'
        })
        supTitle = this.flux.stores.groups.getTitle() + ': ' + this.flux.stores.groups.findOne({id:id}).title
        titleAttribute = ' related '
        break
      case 'all' : 
        recommendations = this.flux.stores.recommendations.entities()
        supTitle = ''
        titleAttribute = ' '
        break
    }            
    
    return {
      count : recommendations.length,
      supTitle : supTitle,
      title :  recommendations.length 
              + titleAttribute 
              + this.flux.stores.recommendations.getTitle(recommendations.length),
      list : _.map(recommendations,function(rec){
         var actions = referencing(this.flux, {
          entity : rec.id, // the recommendation id
          attr : 'recommendations',
          from : 'actions'
         })
        return {
          id : rec.id,
          title : rec.title,
          addressed : actions.length > 0,
          accepted : rec.response === 'Accepted'
        }
      },this)
    }
  
  },
  
  // alist of categories (used in all actions report)
  prepareCategoriesContentList : function(categoryType){
    var categories
    switch (categoryType) {
      case 'issue' : 
        categories = this.flux.stores.issues.entities()
        break
      case 'group' : 
        categories = this.flux.stores.groups.entities()
        break
      case 'agency' : 
        categories = this.flux.stores.agencies.entities()
        break
      
    }            
    return _.map(categories,function(cat){
      return prepareCategoryContent('all',categoryType,cat.id)
    })
  },
    
  // content for all report actions (category and all actions reports)
  prepareActionsContentList : function(reportType, id){
    var actions
    switch (reportType) {
      case 'issue' : 
        actions = referencing(this.flux, {
          entity : id, // the issue
          attr : 'issues',
          from : 'actions'
        })
        break
      case 'group' : 
        actions = referencing(this.flux, {
          entity : id, // the group
          attr : 'groups',
          from : 'actions'
        })
        break
      case 'agency' : 
        actions = referencing(this.flux, {
          entity : id, // the group
          attr : 'agencies',
          from : 'actions'
        })
        break
      case 'all' : 
        actions = this.flux.stores.actions.entities()
        break
    }            
    return _.map(actions,function(action){
      return prepareActionContent(action.id)
    })
  },
  
  
  
  
  
  
  
  isNumeric: function( obj ) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    return obj - parseFloat( obj ) >= 0;
  }  
  
})

module.exports = PrintStore
