// flux
var Fluxxor = require('fluxxor')
var actions = require('actions')

// helpers
var _       = require('lodash')
var log     = require('debug')('src:node_modules:stores:print-store')

//utils
var marked = require('utils/parse-markdown')
var checkSMART = require('utils/checkSMART')
var referencing = require('utils/referencing')
var formatDate = require('utils/formatDate')

//print
var printPdf = require('printPdf/printPdf')



// Print Store handles export to pdf functionality
var PrintStore = Fluxxor.createStore({

  initialize: function (options) {
    

    // route actions
    this.bindActions(
      actions.constants.PRINT, this.print
    )
  },

  print: function (payload) {    
    this.waitFor(
      ['actions', 'issues', 'groups', 'agencies', 'recommendations'],
      function (actionStore, issueStore, groupStore, agencyStore, recommendationStore) {           
        
        var report = {}
        report.type = payload.type
        report.id = payload.id        
        report.data = {}
        // gather data
        // prepare report data based on report type
        switch (payload.type) {
         // single action report
          case 'action' :           
            // prepare data
            report.data = {
              actionData        : this.prepareActionData( payload.id),              
              recommendationsTable : this.prepareRecommendationsTable( payload.type, payload.id)
            }

            break

          // issue category report
          case 'issue' : case 'group' : case 'agency' : 
            // prepare data
            report.data = {            
              categoryData : this.prepareCategoryData( payload.type, payload.type, payload.id),            
              actionsDataList : this.prepareActionsDataList( payload.type, payload.id)            
            }

            break

          // full report
          case 'all' :

            // prepare data
            report.data = {            
              categoriesDataList : {
                issues : this.prepareCategoriesDataList('issue'),
                groups : this.prepareCategoriesDataList('group'),
                agencies : this.prepareCategoriesDataList('agency')
              },
              actionsDataList : this.prepareActionsDataList( payload.type),             
              recommendationsTable : this.prepareRecommendationsTable( payload.type)
            }

            break
        }  


        // call print routine
        printPdf(report)                
        
      } // end callback function (on store load)
    )
  },
  
  
  // content for one single action
  prepareActionData: function (id) {
        
    var action = this.flux.stores.actions.findOne({id: id})
    
    var issues = 
            referencing(this.flux, { entity: action, attr: 'issues', to: 'issues' })
    var groups = 
            referencing(this.flux, { entity: action, attr: 'groups', to: 'groups' })
    var agencies = 
            referencing(this.flux, { entity: action, attr: 'agencies', to: 'agencies' })
    var recommendations = 
            referencing(this.flux, { entity: action, attr: 'recommendations', to: 'recommendations' })
    
    return {
      id : id,
      title : action.title,
      content : [
        { title: 'Description', type :'html', content : marked(action.description) },
        { title: 'Desired Outcome', type :'html', content : marked(action.desiredoutcome) },
        { title: 'Measures',type :'html', content : marked(action.measures) },
        _.isEmpty(action.targetdate) 
          ? { title:'Target Date', type : 'text', content : action.targetdatecomment }
          : { title:'Target Date', type : 'textList', content : [formatDate(action.targetdate), action.targetdatecomment]}          
      ],
      smart : [
        checkSMART(action.isspecific),
        checkSMART(action.ismeasurable),
        checkSMART(action.isassignable),
        checkSMART(action.isresultoriented),
        checkSMART(action.istimebound)
      ],
      categories : {
        issues : _.pluck(issues,'title'),
        groups : _.pluck(groups,'title'),
        agencies : _.pluck(agencies,'title'),
      },
      recommendations : _.pluck(recommendations,'id')
      
    }

  },
  
  // content for a single category
  prepareCategoryData : function(reportType, categoryType, id){
    var category
    var supTitle
    var contentMain
    var contentAside
    var recommendationsList
    var recommendationsTable
    var recommendationsAttribute

    switch (categoryType) {
      case 'issue' : 
        category = this.flux.stores.issues.findOne({ id: id })
        supTitle = this.flux.stores.issues.getTitle(1),
        contentMain = category.currentcontext
        contentAside = category.otherissuesraised
        if (reportType === 'all') {
          var recommendations = referencing(this.flux, {
            entity : category, // the issue/group
            attr : 'issues',
            from : 'recommendations'
          })
          recommendationsList = _.pluck(recommendations,'id')
        } else if (reportType === 'issue') {
          recommendationsTable = this.prepareRecommendationsTable(categoryType,id)
        }
        break
      case 'group' : 
        category = this.flux.stores.groups.findOne({ id: id })
        supTitle = this.flux.stores.groups.getTitle(1)
        contentMain = category.commentary
        contentAside = category.description
        if (reportType === 'all') {
          var recommendations = referencing(this.flux, {
            entity : category, // the issue/group
            attr : 'groups',
            from : 'recommendations'
          })
          recommendationsList = _.pluck(recommendations,'id')
          // included as list on category page
        } else if (reportType === 'group') {
          recommendationsTable = this.prepareRecommendationsTable(categoryType,id)
          // included as table on its own page
        }
        break
      case 'agency' : 
        category = this.flux.stores.agencies.findOne({ id: id })
        supTitle = this.flux.stores.agencies.getTitle(1)
        contentMain = category.description
        contentAside = category.link
        break
    }  
            
    return {
      supTitle : supTitle,
      title : category.title,
      content : { type :'html', content : contentMain },
      aside : { type :'html', content : contentAside },
      recommendationsList : recommendationsList,
      recommendationsTable : recommendationsTable,
      actionsTable : this.prepareActionsTable(reportType, categoryType, id)
    }
  },
  
  // an action index table (used in category content)
  prepareActionsTable: function(reportType,categoryType,id){
    
    var actions 
    var supTitle    
    
    switch (categoryType) {
      case 'issue' : 
        actions = referencing(this.flux, {
          entity : id, // the issue
          attr : 'issues',
          from : 'actions'
        })
        supTitle = this.flux.stores.issues.getTitle() + ': ' + this.flux.stores.issues.findOne({id:id}).title
        break
      case 'group' : 
        actions = referencing(this.flux, {
          entity : id, // the group
          attr : 'groups',
          from : 'actions'
        })
        supTitle = this.flux.stores.groups.getTitle() + ': ' + this.flux.stores.groups.findOne({id:id}).title
        break
      case 'agency' : 
        actions = referencing(this.flux, {
          entity : id, // the group
          attr : 'agencies',
          from : 'actions'
        })
        supTitle = this.flux.stores.agencies.getTitle() + ': ' + this.flux.stores.agencies.findOne({id:id}).title
        break
    }            
    
    var allActions = reportType === 'all' ?  this.flux.stores.actions.entities() : actions
    
    var pageNo = 0
    var indexOfActions = _.map(allActions, function (action) {
      var pageNoToUse = pageNo + 1
      pageNo += (this.isNumeric(action.printnoofpages) ? parseInt(action.printnoofpages) : 1)
      return {id: action.id, pageNo: pageNoToUse}
    },this) 
    
    return {
      count : actions.length,
      supTitle : supTitle,
      title :  actions.length + ' ' + this.flux.stores.recommendations.getTitle(actions.length),
      list : _.map(actions,function(action){         
        return {
          id : action.id,
          title : action.title,
          isspecific : checkSMART(action.isspecific),
          ismeasurable : checkSMART(action.ismeasurable),
          isassignable : checkSMART(action.isassignable),
          isresultoriented : checkSMART(action.isresultoriented),
          istimebound : checkSMART(action.istimebound),
          pageNo : _.findWhere(indexOfActions, {id: action.id}).pageNo 
        }
      })
    }
   
    
  },
  
   // a recommendation table (used in category content)
  prepareRecommendationsTable: function(type,id){
    
    var recommendations 
    var supTitle    
    var titleAttribute 
    
    switch (type) {
      case 'action' :      
        recommendations = referencing(this.flux, {
          entity: this.flux.stores.actions.findOne({id:id}), // the action
          attr: 'recommendations',
          to: 'recommendations'
        })
        supTitle = 'Action ' + id
        titleAttribute = ' addressed '
        break
      case 'issue' : 
        recommendations = referencing(this.flux, {
          entity : id, // the issue
          attr : 'issues',
          from : 'recommendations'
        })
        supTitle = this.flux.stores.issues.getTitle() + ': ' + this.flux.stores.issues.findOne({id:id}).title
        titleAttribute = ' related '                
        break
      case 'group' : 
        recommendations = referencing(this.flux, {
          entity : id, // the group
          attr : 'groups',
          from : 'recommendations'
        })
        supTitle = this.flux.stores.groups.getTitle() + ': ' + this.flux.stores.groups.findOne({id:id}).title
        titleAttribute = ' related '
        break
      case 'all' : 
        recommendations = this.flux.stores.recommendations.entities()
        supTitle = ''
        titleAttribute = ' '
        break
    }            
    
    return {
      count : recommendations.length,
      supTitle : supTitle,
      title :  recommendations.length 
              + titleAttribute 
              + this.flux.stores.recommendations.getTitle(recommendations.length),
      list : _.map(recommendations,function(rec){
         var actions = referencing(this.flux, {
          entity : rec.id, // the recommendation id
          attr : 'recommendations',
          from : 'actions'
         })
        return {
          id : rec.id,
          title : rec.title,
          addressed : actions.length > 0,
          accepted : rec.response === 'Accepted'
        }
      },this)
    }
  
  },
  
  // alist of categories (used in all actions report)
  prepareCategoriesDataList : function(categoryType){
    var categories
    switch (categoryType) {
      case 'issue' : 
        categories = this.flux.stores.issues.entities()
        break
      case 'group' : 
        categories = this.flux.stores.groups.entities()
        break
      case 'agency' : 
        categories = this.flux.stores.agencies.entities()
        break
      
    }            
    return _.map(categories,function(cat){
      return this.prepareCategoryData('all',categoryType,cat.id)
    },this)
  },
    
  // content for all report actions (category and all actions reports)
  prepareActionsDataList : function(reportType, id){
    var actions
    switch (reportType) {
      case 'issue' : 
        actions = referencing(this.flux, {
          entity : id, // the issue
          attr : 'issues',
          from : 'actions'
        })
        break
      case 'group' : 
        actions = referencing(this.flux, {
          entity : id, // the group
          attr : 'groups',
          from : 'actions'
        })
        break
      case 'agency' : 
        actions = referencing(this.flux, {
          entity : id, // the group
          attr : 'agencies',
          from : 'actions'
        })
        break
      case 'all' : 
        actions = this.flux.stores.actions.entities()
        break
    }            
    return _.map(actions,function(action){
      return this.prepareActionData(action.id)
    },this)
  },
  
  
  
  
  
  
  
  isNumeric: function( obj ) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    return obj - parseFloat( obj ) >= 0;
  }  
  
})

module.exports = PrintStore
